{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TumorTwin!","text":"<p><code>TumorTwin</code> is a python package for creating image-guided digital twins in oncology.</p> <p>This documentation is still under construction. </p> <p>For installation instructions, see Installation</p> <p>For licensing information,  instructions, see License</p>"},{"location":"LICENSE/","title":"License Information","text":"<p>TumorTwin is licensed under a UT Austin Research License, which generally prohibits commercial use. See full license information below</p> <p>TumorTwin</p> <p>8681 YAN</p> <p>UT AUSTIN RESEARCH LICENSE (NONCONFIDENTIAL SOURCE CODE)</p> <p>The University of Texas at Austin has developed certain software and documentation that it desires to make available without charge to anyone for academic, research, experimental or personal use. If you wish to distribute or make other use of the software, you may purchase a license to do so from The University of Texas at Austin (licensing@otc.utexas.edu). The accompanying source code is made available to you under the terms of this UT Research License (this \"UTRL\"). By installing or using the code, you are consenting to be bound by this UTRL. If you do not agree to the terms and conditions of this license, do not install or use any part of the code. The terms and conditions in this UTRL not only apply to the source code made available by Licensor, but also to any improvements to, or derivative works of, that source code made by you and to any object code compiled from such source code, improvements or derivative works.</p> <ol> <li> <p>DEFINITIONS.</p> <p>1.1 \"Commercial Use\" shall mean use of Software or Documentation by Licensee for direct or indirect financial, commercial or strategic gain or advantage, including without limitation: (a) bundling or integrating the Software with any hardware product or another software product for transfer, sale or license to a third party (even if distributing the Software on separate media and not charging for the Software); (b) providing customers with a link to the Software or a copy of the Software for use with hardware or another software product purchased by that customer; or (c) use in connection with the performance of services for which Licensee is compensated.</p> <p>1.2 \"Derivative Products\" means any improvements to, or other derivative works of, the Software made by Licensee, and any computer software programs, and accompanying documentation, developed by Licensee which are a modification of, enhancement to, derived from or based upon the Licensed Software or documentation provided by Licensor for the Licensed Software, and any object code compiled from such computer software programs.</p> <p>1.3 \"Documentation\" shall mean all manuals, user documentation, and other related materials pertaining to the Software that are made available to Licensee in connection with the Software.</p> <p>1.4 \"Licensor\" shall mean The University of Texas at Austin, on behalf of the Board of Regents of the University of Texas System, an agency of the State of Texas, whose address is 3925 W. Braker Lane, Suite 1.9A (R3500), Austin, Texas 78759.</p> <p>1.5 \"Licensee\" or \"you\" shall mean the person or entity that has agreed to the terms hereof and is exercising rights granted hereunder.</p> <p>1.6 \"Software\" shall mean the computer program(s) referred to as: \"TumorTwin ViG\" (UT Tech ID 8681 YAN), which is made available under this UTRL in source code form, including any error corrections, bug fixes, patches, updates or other modifications that Licensor may in its sole discretion make available to Licensee from time to time, and any object code compiled from such source code.</p> </li> <li> <p>GRANT OF RIGHTS.</p> <p>Subject to the terms and conditions hereunder, Licensor hereby grants to Licensee a worldwide, non-transferable, non-exclusive license to (a) install, use and reproduce the Software for academic, research, experimental and personal use (but specifically excluding Commercial Use); (b) use and modify the Software to create Derivative Products, subject to Section 3.2; (c) use the Documentation, if any, solely in connection with Licensee's authorized use of the Software; and (d) a non-exclusive, royalty-free license for academic, research, experimental and personal use (but specifically excluding Commercial Use) to those patents, of which Thomas Yankeelov is a named inventor, that are licensable by Licensee and that are necessarily infringed by such authorized use of the Software, and solely in connection with Licensee's authorized use of the Software.</p> </li> <li> <p>RESTRICTIONS; COVENANTS.</p> <p>3.1 Licensee may not: (a) distribute, sub-license or otherwise transfer copies or rights to the Software (or any portion thereof) or the Documentation; (b) use the Software (or any portion thereof) or Documentation for Commercial Use, or for any other use except as described in Section 2; (c) copy the Software or Documentation other than for archival and backup purposes; or (d) remove any product identification, copyright, proprietary notices or labels from the Software and Documentation. This UTRL confers no rights upon Licensee except those expressly granted herein.</p> <p>3.2 Derivative Products. Licensee hereby agrees that it will provide a copy of all Derivative Products to Licensor and that its use of the Derivative Products will be subject to all of the same terms, conditions, restrictions and limitations on use imposed on the Software under this UTRL. Licensee hereby grants Licensor a worldwide, non-exclusive, royalty-free license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense and distribute Derivative Products. Licensee also hereby grants Licensor a worldwide, non-exclusive, royalty-free patent license to make, have made, use, offer to sell, sell, import and otherwise transfer the Derivative Products under those patent claims, from patents of which Thomas Yankeelov is a named inventor, that licensable by Licensee that are necessarily infringed by the Derivative Products.</p> </li> <li> <p>CONFIDENTIALITY; PROTECTION OF SOFTWARE.</p> <p>4.1 Reserved.</p> <p>4.2 Proprietary Notices. Licensee shall maintain and place on any copy of Software or Documentation that it reproduces for internal use all notices as are authorized and/or required hereunder. Licensee shall include a copy of this UTRL and the following notice, on each copy of the Software and Documentation. Such license and notice shall be embedded in each copy of the Software, in the video screen display, on the physical medium embodying the Software copy and on any Documentation: Copyright (c) 2021, The University of Texas at Austin. All rights reserved. UNIVERSITY EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES CONCERNING THIS SOFTWARE AND DOCUMENTATION, INCLUDING ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR ANY PARTICULAR PURPOSE, NON-INFRINGEMENT AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY THAT MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF TRADE. NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF THE SOFTWARE OR DOCUMENTATION. Under no circumstances shall University be liable for incidental, special, indirect, direct or consequential damages or loss of profits, interruption of business, or related expenses which may arise from use of Software or Documentation, including but not limited to those resulting from defects in Software and/or Documentation, or loss or inaccuracy of data of any kind.</p> </li> <li> <p>WARRANTIES.</p> <p>5.1 Disclaimer of Warranties. TO THE EXTENT PERMITTED BY APPLICABLE LAW, THE SOFTWARE AND DOCUMENTATION ARE BEING PROVIDED ON AN \"AS IS\" BASIS WITHOUT ANY WARRANTIES OF ANY KIND RESPECTING THE SOFTWARE OR DOCUMENTATION, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY OF DESIGN, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.</p> <p>5.2 Limitation of Liability. UNDER NO CIRCUMSTANCES UNLESS REQUIRED BY APPLICABLE LAW SHALL LICENSOR BE LIABLE FOR INCIDENTAL, SPECIAL, INDIRECT, DIRECT OR CONSEQUENTIAL DAMAGES OR LOSS OF PROFITS, INTERRUPTION OF BUSINESS, OR RELATED EXPENSES WHICH MAY ARISE AS A RESULT OF THIS LICENSE OR OUT OF THE USE OR ATTEMPT OF USE OF SOFTWARE OR DOCUMENTATION INCLUDING BUT NOT LIMITED TO THOSE RESULTING FROM DEFECTS IN SOFTWARE AND/OR DOCUMENTATION, OR LOSS OR INACCURACY OF DATA OF ANY KIND. THE FOREGOING EXCLUSIONS AND LIMITATIONS WILL APPLY TO ALL CLAIMS AND ACTIONS OF ANY KIND, WHETHER BASED ON CONTRACT, TORT (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE), OR ANY OTHER GROUNDS.</p> </li> <li> <p>INDEMNIFICATION.     Licensee shall indemnify, defend and hold harmless Licensor, the University of Texas System, their Regents, and their officers, agents and employees from and against any claims, demands, or causes of action whatsoever caused by, or arising out of, or resulting from, the exercise or practice of the license granted hereunder by Licensee, its officers, employees, agents or representatives.</p> </li> <li> <p>TERMINATION.     If Licensee breaches this UTRL, Licensee's right to use the Software and Documentation will terminate immediately without notice, but all provisions of this UTRL except Section 2 will survive termination and continue in effect. Upon termination, Licensee must destroy all copies of the Software and Documentation.</p> </li> <li> <p>GOVERNING LAW; JURISDICTION AND VENUE.     The validity, interpretation, construction and performance of this UTRL shall be governed by the laws of the State of Texas. The Texas state courts of Travis County, Texas (or, if there is exclusive federal jurisdiction, the United States District Court for the Western District of Texas) shall have exclusive jurisdiction and venue over any dispute arising out of this UTRL, and Licensee consents to the jurisdiction of such courts. Application of the United Nations Convention on Contracts for the International Sale of Goods is expressly excluded.</p> </li> <li> <p>EXPORT CONTROLS.     This license is subject to all applicable export restrictions. Licensee must comply with all export and import laws and restrictions and regulations of any United States or foreign agency or authority relating to the Software and its use.</p> </li> <li> <p>U.S. GOVERNMENT END-USERS.     The Software is a \"commercial item,\" as that term is defined in 48 C.F.R. 2.101, consisting of \"commercial computer software\" and \"commercial computer software documentation,\" as such terms are used in 48 C.F.R. 12.212 (Sept. 1995) and 48 C.F.R. 227.7202 (June 1995). Consistent with 48 C.F.R. 12.212, 48 C.F.R. 27.405(b)(2) (June 1998) and 48 C.F.R. 227.7202, all U.S. Government End Users acquire the Software with only those rights as set forth herein.</p> </li> <li> <p>MISCELLANEOUS     If any provision hereof shall be held illegal, invalid or unenforceable, in whole or in part, such provision shall be modified to the minimum extent necessary to make it legal, valid and enforceable, and the legality, validity and enforceability of all other provisions of this UTRL shall not be affected thereby. Licensee may not assign this UTRL in whole or in part, without Licensor's prior written consent. Any attempt to assign this UTRL without such consent will be null and void. This UTRL is the complete and exclusive statement between Licensee and Licensor relating to the subject matter hereof and supersedes all prior oral and written and all contemporaneous oral negotiations, commitments and understandings of the parties, if any. Any waiver by either party of any default or breach hereunder shall not constitute a waiver of any provision of this UTRL or of any subsequent default or breach of the same or a different kind.</p> </li> </ol> <p>END OF LICENSE</p>"},{"location":"contributing/","title":"Instructions for Developers","text":"<p>We would love for you to contribute new code, bugfixes, or documentation! </p>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<p>We use a git-based feature branch workflow. This means that new development should happen on a feature-specific branch, which will then be merged in to the <code>main</code> branch via a pull request that includes a peer-review of the feature code.</p> <p>Here is an outline of the workflow:</p> <ol> <li> <p>Check out the <code>main</code> branch and ensure it is up-to-date with the remote repository <pre><code>git checkout main\ngit fetch origin\n</code></pre></p> </li> <li> <p>Create a new branch for your feature: <pre><code>git checkout -b my-awesome-feature\n</code></pre></p> </li> <li> <p>Develop your feature on the feature branch, using some combination of commands like <pre><code>git status\ngit add &lt;some-file&gt;\ngit commit -m \"add some-file\"\n</code></pre> at this stage you can also <code>git push</code> your branch to the remote repository if you want others to see and/or collaborate on your branch, or you can keep it local.</p> </li> <li> <p>Once you have finished developing your feature, you should perform some housekeeping to ensure your code conforms to standards:</p> </li> </ol> <p>Note: if you have access to <code>make</code> on your system, you can run the following commands via the shortcuts <code>make format</code>, <code>make lint</code>, and <code>make test</code> (see <code>Makefile</code>)</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> <p>Request that your feature branch be merged in to the <code>main</code> branch by opening a pull-request.</p> </li> </ul> <p>Navigate to the Pull Requests tab on github. Click <code>New pull request</code> and follow the instructions. You should assign yourself to the pull request, and you can request a code review by assigning a reviewer (Alternatively, post on the group slack to say that a feature is ready for review!) </p> <ol> <li>Address Code Review comments</li> </ol> <p>The code reviewer may make ask questions or suggest improvements via comments on the pull request. Simply address the comments via new commits to your feature branch</p> <ol> <li>Merge your feature!</li> </ol> <p>Hit merge in the pull request on github. <code>Merge and Squash</code> is the prefered method, as this will squash all of your feature commits into a single commit, keeping the <code>main</code> branch history clean.</p>"},{"location":"contributing/#ensure-that-your-branch-is-up-to-date-with-main","title":"Ensure that your branch is up-to-date with main:","text":"<p>Other developers may have committed changes to <code>main</code> since you started your branch. You should make sure you pull in those changes to avoid merge conflicts. To do this, from your feature branch run: <pre><code>git merge main\n</code></pre></p>"},{"location":"contributing/#format-your-code","title":"Format your code:","text":"<p>These tools will automatically format your code files to match our chosen formatting standard. <pre><code>black tumortwin\nisort --profile black tumortwin\n</code></pre></p>"},{"location":"contributing/#lint-your-code","title":"Lint your code:","text":"<p>These tools will run some static code analysis tools to point out possible issues or improvements. You should try to fix as many of the issues flagged as possible. If there is something that you aren't sure about, feel free to note it in a comment in your pull request (next step) <pre><code>flake8 tumortwin\nmypy tumortwin\n</code></pre></p>"},{"location":"contributing/#run-automated-tests","title":"Run automated tests","text":"<p>This will run automated tests that we have written, to ensure that your feature hasn't broken some functionality elsewhere. You should also add tests for your new feature! <pre><code>pytest tests\n</code></pre></p>"},{"location":"installation/","title":"Installation","text":"<ol> <li>Make sure you have Python 3.10 or higher (currently tested on Python 3.12)</li> <li>Setting up python environments using Anaconda and Python 3.12<ul> <li>Install Anaconda</li> <li>Setup Python environment with python 3.12 using <code>conda create -n [ENV_NAME] python=3.12 anaconda</code></li> <li>Activate Python environment using <code>conda activate [ENV_NAME]</code></li> </ul> </li> <li>Clone <code>TumorTwin</code> repository: <code>git clone https://github.com/OncologyModelingGroup/TumorTwin.git</code> using your GitHub credentials.</li> <li>Navigate into the cloned folder <code>cd TumorTwin</code></li> <li>Install dependencies using <code>pip install .</code> or <code>pip install -e .</code> to install in development mode.</li> <li>Open <code>HGG_Demo.ipynb.</code> and run the notebook.</li> </ol>"},{"location":"theory/","title":"Theory","text":"<p>Theory paper coming soon!</p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Here you will find some tutorials/demos, in the form of Jupyter notebooks, covering various aspects and usecases of the package.</p>"},{"location":"tutorials/#end-to-end-demos","title":"End-to-end Demos:","text":"<ul> <li>High-grade Glioma</li> <li>Triple-negative Breast Cancer</li> </ul>"},{"location":"tutorials/#specific-tumortwin-functionality","title":"Specific TumorTwin Functionality:","text":"<ul> <li>Gradient computation</li> <li>Cropping</li> </ul>"},{"location":"api/models/base/","title":"Model Base Class","text":""},{"location":"api/models/base/#tumortwin.models.base.TumorGrowthModel3D","title":"<code>TumorGrowthModel3D</code>","text":"<p>               Bases: <code>Module</code></p> <p>A base class for 3D tumor growth models using PyTorch.</p> <p>This class defines the interface for tumor growth models that can simulate tumor dynamics in a 3D environment. Subclasses must implement the <code>forward</code> method to define the model-specific behavior.</p>"},{"location":"api/models/base/#tumortwin.models.base.TumorGrowthModel3D.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the base class.</p> <p>This constructor calls the parent PyTorch <code>nn.Module</code> initializer.</p>"},{"location":"api/models/base/#tumortwin.models.base.TumorGrowthModel3D.forward","title":"<code>forward(t, u)</code>","text":"<p>Defines the forward pass for the tumor growth model.</p> <p>Subclasses must implement this method to specify the model's behavior during the forward pass.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Tensor</code> <p>A tensor representing time points, typically of shape <code>(batch_size, 1)</code>.</p> required <code>u</code> <code>Tensor</code> <p>A tensor representing the input state, such as tumor properties or environmental variables, typically of shape <code>(batch_size, ...)</code>.</p> required <p>Returns:</p> Name Type Description <code>du_dt</code> <code>Tensor</code> <p>A tensor representing the computed output state, typically of the same shape as <code>u</code>.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method is not implemented in a subclass.</p>"},{"location":"api/models/rxdx/","title":"Reaction-Diffusion model","text":""},{"location":"api/models/rxdx/#tumortwin.models.reaction_diffusion_3d.ReactionDiffusion3D","title":"<code>ReactionDiffusion3D</code>","text":"<p>               Bases: <code>TumorGrowthModel3D</code></p> <p>A 3D reaction-diffusion model for simulating tumor growth.</p> <p>This class extends the <code>TumorGrowthModel3D</code> base class to implement a reaction-diffusion framework with support for radiotherapy and chemotherapy. The model incorporates spatial diffusion, proliferation dynamics, and treatment effects.</p> <p>Attributes:</p> Name Type Description <code>k</code> <code>Tensor</code> <p>Tumor growth rate parameter (proliferation rate).</p> <code>d</code> <code>Tensor</code> <p>Tumor diffusion coefficient (spatial spread rate).</p> <code>theta</code> <code>Tensor</code> <p>Carrying capacity of the tumor cells (maximum density).</p> <code>bcs</code> <code>Tensor</code> <p>Boundary conditions derived from the patient brain mask.</p> <code>brain_mask</code> <code>Tensor</code> <p>Binary mask indicating the brain region.</p> <code>radiotherapy_specification</code> <code>Optional[RadiotherapySpecification]</code> <p>Specification of radiotherapy protocol.</p> <code>radiotherapy_days</code> <code>Optional[dict]</code> <p>Dictionary mapping days (since initial time) to radiotherapy doses.</p> <code>chemotherapy_specifications</code> <code>Optional[List[ChemotherapySpecification]]</code> <p>List of chemotherapy protocols.</p> <code>t_initial</code> <code>datetime</code> <p>Initial time of the simulation.</p> <code>fd_stencil_backward_coeff</code> <code>List[Tensor]</code> <p>Backward finite-difference coefficients for each axis.</p> <code>fd_stencil_central_coeff</code> <code>List[Tensor]</code> <p>Central finite-difference coefficients for each axis.</p> <code>fd_stencil_forward_coeff</code> <code>List[Tensor]</code> <p>Forward finite-difference coefficients for each axis.</p> <code>device</code> <code>device</code> <p>The device on which to perform computations (e.g., CPU or GPU).</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the model with parameters and treatment specifications.</p> <code>forward</code> <p>Computes the rate of change of tumor density at a given time step.</p> <code>callback_step</code> <p>Applies treatment effects (e.g., radiotherapy) and ensures constraints on the tumor density.</p> <code>_compute_laplacian</code> <p>Computes the spatial Laplacian of the tumor density field.</p> <code>_backward_slice</code> <p>Extracts the backward slice along a given axis.</p> <code>_central_slice</code> <p>Extracts the central slice along a given axis.</p> <code>_forward_slice</code> <p>Extracts the forward slice along a given axis.</p>"},{"location":"api/models/rxdx/#tumortwin.models.reaction_diffusion_3d.ReactionDiffusion3D.__init__","title":"<code>__init__(k, d, theta, patient_data, initial_time, *, radiotherapy_specification=None, chemotherapy_specifications=None, radiotherapy_days=None, require_grad=True, device=torch.device('cpu'))</code>","text":"<p>Initializes the ReactionDiffusion3D model with patient-specific data and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>Tensor</code> <p>Tumor proliferation rate tensor.</p> required <code>d</code> <code>Tensor</code> <p>Tumor diffusion coefficient tensor.</p> required <code>theta</code> <code>Tensor</code> <p>Tumor carrying capacity tensor.</p> required <code>patient_data</code> <code>HGGPatientData</code> <p>Patient-specific data including brain mask and imaging.</p> required <code>initial_time</code> <code>datetime</code> <p>Initial simulation time.</p> required <code>radiotherapy_specification</code> <code>Optional[RadiotherapySpecification]</code> <p>Radiotherapy protocol.</p> <code>None</code> <code>chemotherapy_specifications</code> <code>Optional[List[ChemotherapySpecification]]</code> <p>Chemotherapy protocols.</p> <code>None</code> <code>radiotherapy_days</code> <code>Optional[dict]</code> <p>Mapping of radiotherapy days to doses.</p> <code>None</code> <code>require_grad</code> <code>bool</code> <p>Whether the parameters <code>k</code> and <code>d</code> require gradients.</p> <code>True</code>"},{"location":"api/models/rxdx/#tumortwin.models.reaction_diffusion_3d.ReactionDiffusion3D.callback_step","title":"<code>callback_step(t, u, dt)</code>","text":"<p>Handles per-step updates during the simulation, including applying treatment effects.</p> <p>This method updates the tumor density field by applying radiotherapy effects (if specified) and ensures the tumor density is clamped within valid bounds.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Tensor</code> <p>Current simulation time.</p> required <code>u</code> <code>Tensor</code> <p>Tumor density field.</p> required <code>dt</code> <code>Tensor</code> <p>Time step duration.</p> required <p>Returns:</p> Name Type Description <code>u</code> <code>Tensor</code> <p>Updated tumor density field.</p>"},{"location":"api/models/rxdx/#tumortwin.models.reaction_diffusion_3d.ReactionDiffusion3D.callback_step_adjoint","title":"<code>callback_step_adjoint(t, u, dt)</code>","text":"<p>Handles per-step updates during the backward pass of the adjoint method.</p> <p>This method updates the adjoint variables by applying radiotherapy effects (if specified).</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Tensor</code> <p>Current simulation time.</p> required <code>u</code> <code>Tensor</code> <p>Adjoint variables.</p> required <code>dt</code> <code>Tensor</code> <p>Time step duration.</p> required <p>Returns:</p> Name Type Description <code>u</code> <code>Tensor</code> <p>Updated adjoint variables.</p>"},{"location":"api/models/rxdx/#tumortwin.models.reaction_diffusion_3d.ReactionDiffusion3D.forward","title":"<code>forward(t, u)</code>","text":"<p>Computes the rate of change of tumor density at a given time step.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Tensor</code> <p>Current simulation time (in days).</p> required <code>u</code> <code>Tensor</code> <p>Tumor density field.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Rate of change of tumor density.</p>"},{"location":"api/postprocessing/qoi/","title":"Quantities of interest","text":""},{"location":"api/postprocessing/qoi/#tumortwin.postprocessing.qoi.compute_ccc","title":"<code>compute_ccc(x, y, bias=True, use_pearson=False)</code>","text":"<p>Compute the concordance correlation coefficient between two arrays x and y.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>First vector.</p> required <code>y</code> <code>ndarray</code> <p>Second vector.</p> required <code>bias</code> <code>bool</code> <p>Bias correction. Defaults to True.</p> <code>True</code> <code>use_pearson</code> <code>bool</code> <p>Use Pearson correlation coefficient. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The concordance correlation coefficient.</p>"},{"location":"api/postprocessing/qoi/#tumortwin.postprocessing.qoi.compute_dice","title":"<code>compute_dice(y_true, y_pred)</code>","text":"<p>Compute the Dice coefficient between y_true and y_pred.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>ndarray</code> <p>Ground truth mask.</p> required <code>y_pred</code> <code>ndarray</code> <p>Predicted mask.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The computed Dice coefficient.</p>"},{"location":"api/postprocessing/qoi/#tumortwin.postprocessing.qoi.compute_voxel_ccc","title":"<code>compute_voxel_ccc(x_img, y_img, roi_img, bias=True, use_pearson=False)</code>","text":"<p>Compute the voxel-wise concordance correlation coefficient between two NIfTI files.</p> <p>Parameters:</p> Name Type Description Default <code>x_img</code> <code>Image3D</code> <p>x image.</p> required <code>y_img</code> <code>Image3D</code> <p>y image.</p> required <code>roi_img</code> <code>Image3D</code> <p>ROI image.</p> required <code>bias</code> <code>bool</code> <p>Bias correction. Defaults to True.</p> <code>True</code> <code>use_pearson</code> <code>bool</code> <p>Use Pearson correlation coefficient. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Voxel-wise concordance correlation coefficient.</p>"},{"location":"api/postprocessing/qoi/#tumortwin.postprocessing.qoi.compute_voxel_dice","title":"<code>compute_voxel_dice(x_img, y_img, threshold=0.5)</code>","text":"<p>Compute voxel-wise Dice coefficient between two NIfTI files.</p> <p>Parameters:</p> Name Type Description Default <code>x_img</code> <code>Image3D</code> <p>x image.</p> required <code>y_img</code> <code>Image3D</code> <p>y image.</p> required <code>threshold</code> <code>float</code> <p>Value to threshold on. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Dice coefficient.</p>"},{"location":"api/postprocessing/qoi/#tumortwin.postprocessing.qoi.compute_voxel_ttc","title":"<code>compute_voxel_ttc(x_img, carrying_capacity)</code>","text":"<p>Compute voxel-wise total tumor cellularity (TTC) from a NIfTI file.</p> <p>Parameters:</p> Name Type Description Default <code>x_img</code> <code>Image3D</code> <p>Image3D object.</p> required <code>carrying_capacity</code> <code>float</code> <p>Carrying capacity.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Total tumor cellularity.</p>"},{"location":"api/postprocessing/qoi/#tumortwin.postprocessing.qoi.compute_voxel_ttv","title":"<code>compute_voxel_ttv(x_img, threshold=0.5)</code>","text":"<p>Compute voxel-wise total tumor volume (TTV) from a NIfTI file.</p> <p>Parameters:</p> Name Type Description Default <code>x_img</code> <code>Image3D</code> <p>Image3D object.</p> required <code>threshold</code> <code>float</code> <p>Threshold for tumor detection. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Total tumor volume.</p>"},{"location":"api/preprocessing/boundary_conditions/","title":"Boundary conditions","text":""},{"location":"api/preprocessing/boundary_conditions/#tumortwin.preprocessing.bound_condition_maker.bound_condition_maker","title":"<code>bound_condition_maker(mask)</code>","text":"<p>Assigns boundary conditions to a binary mask and returns a 4D array representing the boundary condition at each voxel in three orthogonal directions.</p> <p>This function processes a 3D binary mask, calculating boundary conditions for each voxel. Boundary conditions can be <code>INTERIOR</code>, <code>FORWARD</code>, <code>BACKWARD</code>, or <code>NONE</code>, depending on the presence of neighboring voxels.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>Image3D</code> <p>A binary mask where non-zero values represent the region of interest.</p> required <p>Returns:</p> Name Type Description <code>Image3D</code> <code>Image3D</code> <p>A 4D array (same spatial dimensions as <code>mask</code>, with an additional axis for the X, Y, and Z directions) containing boundary condition values for each voxel and direction.</p>"},{"location":"api/preprocessing/boundary_conditions/#tumortwin.preprocessing.bound_condition_maker.bound_condition_maker_inner","title":"<code>bound_condition_maker_inner(mask, padded_mask)</code>","text":"<p>Core implementation for computing boundary conditions.</p> <p>This function iterates over all non-zero voxels in the mask and determines the boundary condition for each voxel in the X, Y, and Z directions.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>A 3D binary mask.</p> required <code>padded_mask</code> <code>ndarray</code> <p>The same mask padded by one voxel in each dimension, to simplify boundary condition calculations.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A 4D array of the same spatial dimensions as <code>mask</code>, with an additional axis for boundary conditions in three directions.</p>"},{"location":"api/preprocessing/boundary_conditions/#tumortwin.preprocessing.bound_condition_maker.check_neighbors","title":"<code>check_neighbors(mask, x, y, z, direction)</code>","text":"<p>Checks the neighbors of a voxel in a specific direction and determines its boundary condition.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>A binary mask (3D array).</p> required <code>x</code> <code>int</code> <p>X-coordinate of the voxel.</p> required <code>y</code> <code>int</code> <p>Y-coordinate of the voxel.</p> required <code>z</code> <code>int</code> <p>Z-coordinate of the voxel.</p> required <code>direction</code> <code>Direction</code> <p>The direction to check (<code>X</code>, <code>Y</code>, or <code>Z</code>).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The boundary condition value (e.g., <code>Boundary.INTERIOR.value</code>, <code>Boundary.FORWARD.value</code>, <code>Boundary.BACKWARD.value</code>, or <code>Boundary.NONE.value</code>).</p>"},{"location":"api/preprocessing/cellularity/","title":"Cellularity estimation","text":""},{"location":"api/preprocessing/cellularity/#tumortwin.preprocessing.cellularity.ADC_to_cellularity","title":"<code>ADC_to_cellularity(ADC, roi_enhance, roi_nonenhance=None)</code>","text":"<p>Converts an ADC map to a cellularity map using region of interest (ROI) masks.</p> <p>This function calculates the cellularity for enhancing and non-enhancing regions based on the apparent diffusion coefficient (ADC) values. Cellularity for non-enhancing regions is set to a fixed literature-based constant.</p> <p>Parameters:</p> Name Type Description Default <code>ADC</code> <code>Image3D</code> <p>The measured apparent diffusion coefficient (ADC) map.</p> required <code>roi_enhance</code> <code>Image3D</code> <p>Binary mask for enhancing regions (e.g., tumors).</p> required <code>roi_nonenhance</code> <code>Image3D</code> <p>Binary mask for non-enhancing regions.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Image3D</code> <code>T</code> <p>The computed cellularity map, normalized between 0 and 1.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If input images have mismatched shape or spacing.</p>"},{"location":"api/preprocessing/cellularity/#tumortwin.preprocessing.cellularity.compute_carrying_capacity","title":"<code>compute_carrying_capacity(brain_mask, cell_size_mm=1e-06, packing_fraction=0.75)</code>","text":"<p>Computes the physical carrying capacity (maximum number of cells) for a voxel.</p> <p>The carrying capacity is calculated based on the voxel volume, a packing fraction, and the average size of a cell.</p> <p>Parameters:</p> Name Type Description Default <code>brain_mask</code> <code>Image3D</code> <p>Binary mask of the brain region.</p> required <code>cell_size_mm</code> <code>float</code> <p>Average cell size in mm\u00b3. Default is 1e-6 mm\u00b3.</p> <code>1e-06</code> <code>packing_fraction</code> <code>float</code> <p>Fraction of voxel space occupied by cells. Default is 0.75.</p> <code>0.75</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The carrying capacity for a single voxel (cells per voxel).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the unit of the brain mask spacing is invalid.</p>"},{"location":"api/preprocessing/crop/","title":"Image cropping","text":""},{"location":"api/preprocessing/crop/#tumortwin.preprocessing.crop.crop_array_to_bounding_box","title":"<code>crop_array_to_bounding_box(array, bounding_box)</code>","text":"<p>Crop an input array to the specified bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The input array to crop.</p> required <code>bounding_box</code> <code>BoundingBoxIndices</code> <p>The bounding box, defined as slices for each dimension of the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The cropped array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the bounding box dimensions are incompatible with the input array.</p>"},{"location":"api/preprocessing/crop/#tumortwin.preprocessing.crop.crop_image_to_bounding_box","title":"<code>crop_image_to_bounding_box(image, bounding_box)</code>","text":"<p>Crop an Image3D object to a specified bounding box.</p> <p>This function modifies the <code>Image3D</code> instance by cropping its internal array data to the provided bounding box and returns a new instance.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image3D</code> <p>The input <code>Image3D</code> object.</p> required <code>bounding_box</code> <code>BoundingBoxIndices</code> <p>The bounding box to crop to.</p> required <p>Returns:</p> Name Type Description <code>Image3D</code> <code>T</code> <p>A new <code>Image3D</code> instance cropped to the specified bounding box.</p>"},{"location":"api/preprocessing/crop/#tumortwin.preprocessing.crop.get_bounding_box","title":"<code>get_bounding_box(mask_array, padding=1)</code>","text":"<p>Get the bounding box of a binary mask array.</p> <p>Parameters:</p> Name Type Description Default <code>mask_array</code> <code>ndarray</code> <p>A binary mask array.</p> required <code>pad</code> <code>int</code> <p>How many voxels to pad the bounding box by. Defaults to 1.</p> required <p>Returns:</p> Name Type Description <code>BoundingBoxIndices</code> <code>BoundingBoxIndices</code> <p>Tuple of slice objects defining the bounding box.</p>"},{"location":"api/preprocessing/crop/#tumortwin.preprocessing.crop.restrict_bounding_box","title":"<code>restrict_bounding_box(small_bbox, large_bbox)</code>","text":"<p>This restricts a bounding box by the domain of another bounding box. For example, when restricting an ROI bounding box to the domain of a brain bounding box.</p> <p>Parameters:</p> Name Type Description Default <code>small_bbox</code> <code>BoundingBoxIndices</code> <p>The smaller bounding box.</p> required <code>large_bbox</code> <code>BoundingBoxIndices</code> <p>The larger bounding box.</p> required <p>Returns:</p> Name Type Description <code>BoundingBoxIndices</code> <code>BoundingBoxIndices</code> <p>The restricted bounding box.</p>"},{"location":"api/solvers/base/","title":"Solver Base Class","text":""},{"location":"api/solvers/base/#tumortwin.solvers.base.ForwardSolver","title":"<code>ForwardSolver</code>","text":"<p>Abstract base class for forward solvers in tumor growth modeling.</p> <p>A forward solver numerically integrates the evolution of the tumor density field over specified timepoints, starting from an initial condition.</p> <p>Methods:</p> Name Description <code>solve</code> <p>Computes the tumor density at each timepoint by solving the growth model. Must be implemented by subclasses.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If a subclass does not implement the <code>solve</code> method.</p>"},{"location":"api/solvers/base/#tumortwin.solvers.base.ForwardSolver.solve","title":"<code>solve(timepoints, u_initial)</code>","text":"<p>Abstract method to solve the tumor growth model.</p> <p>Parameters:</p> Name Type Description Default <code>timepoints</code> <code>List[datetime]</code> <p>List of timepoints at which the solution is desired.</p> required <code>u_initial</code> <code>Tensor</code> <p>Initial tumor density field.</p> required <p>Returns:</p> Type Description <code>Tuple[List[datetime], List[Tensor]]</code> <p>Tuple[List[datetime], List[torch.Tensor]]: - List of datetime objects corresponding to the solution timepoints. - List of torch.Tensor objects representing the tumor density at each timepoint.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by a subclass.</p>"},{"location":"api/solvers/torchdiffeq/","title":"PyTorch DiffEq solver","text":""},{"location":"api/solvers/torchdiffeq/#tumortwin.solvers.torch_solver.TorchDiffEqSolver","title":"<code>TorchDiffEqSolver</code>","text":"<p>               Bases: <code>ForwardSolver</code></p> <p>ODE-based forward solver using the TorchDiffEq library.</p> <p>This solver integrates tumor growth models over specified timepoints using advanced ODE solvers and handles both radiotherapy and chemotherapy schedules.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>TumorGrowthModel3D</code> <p>The tumor growth model to solve.</p> <code>solver_options</code> <code>TorchDiffEqSolverOptions</code> <p>Configuration options for the solver.</p>"},{"location":"api/solvers/torchdiffeq/#tumortwin.solvers.torch_solver.TorchDiffEqSolver.__init__","title":"<code>__init__(model, solver_options)</code>","text":"<p>Initializes the TorchDiffEqSolver.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>TumorGrowthModel3D</code> <p>The tumor growth model to solve.</p> required <code>solver_options</code> <code>TorchDiffEqSolverOptions</code> <p>Configuration options for the solver.</p> required"},{"location":"api/solvers/torchdiffeq/#tumortwin.solvers.torch_solver.TorchDiffEqSolver.grid_constructor","title":"<code>grid_constructor(func, y0, t)</code>","text":"<p>Constructs a grid of timesteps considering treatment schedules.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The ODE function (unused in this method but required by the API).</p> required <code>y0</code> <p>Initial state of the system (unused in this method but required by the API).</p> required <code>t</code> <p>Original list of timepoints requested by the solver.</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Tensor containing refined timepoints for integration.</p>"},{"location":"api/solvers/torchdiffeq/#tumortwin.solvers.torch_solver.TorchDiffEqSolver.solve","title":"<code>solve(timepoints, u_initial)</code>","text":"<p>Solves the tumor growth model over the specified timepoints.</p> <p>Parameters:</p> Name Type Description Default <code>timepoints</code> <code>List[datetime]</code> <p>List of timepoints at which the solution is desired.</p> required <code>u_initial</code> <code>Tensor</code> <p>Initial tumor density field.</p> required <p>Returns:</p> Type Description <code>Tuple[List[datetime], List[Tensor]]</code> <p>Tuple[List[datetime], List[torch.Tensor]]: - A list of datetime objects corresponding to the solution timepoints. - A list of torch.Tensor objects representing the tumor density at each timepoint.</p>"},{"location":"api/solvers/torchdiffeq/#tumortwin.solvers.torch_solver.TorchDiffEqSolverOptions","title":"<code>TorchDiffEqSolverOptions</code>  <code>dataclass</code>","text":"<p>Configuration options for the TorchDiffEqSolver.</p> <p>Attributes:</p> Name Type Description <code>step_size</code> <code>timedelta</code> <p>The integration step size for the solver.</p> <code>method</code> <code>str</code> <p>The ODE solver method to use (e.g., \"rk4\", \"dopri5\").</p> <code>device</code> <code>device</code> <p>The device on which to perform computations (e.g., CPU or GPU).</p> <code>use_adjoint</code> <code>bool</code> <p>Whether to use the adjoint method for memory-efficient backpropagation.</p>"},{"location":"api/types/imaging/","title":"Imaging","text":"<p>The imaging module contains types for working with medical imaging data.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.CropSettings","title":"<code>CropSettings</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration settings for cropping medical images.</p> <p>Attributes:</p> Name Type Description <code>crop_to</code> <code>CropTarget</code> <p>The target area to crop. Defaults to <code>CropTarget.ANATOMY</code>.</p> <code>padding</code> <code>int</code> <p>The amount of padding to apply around the cropped area. Defaults to 1.</p> <code>visit_index</code> <code>Optional[int]</code> <p>Specifies which visit's ROI to use when <code>crop_to</code> is <code>ROI_ENHANCE</code> or <code>ROI_NONENHANCE</code>. If <code>None</code>, the union of all available ROIs is used. If an integer is provided, only the ROI from that specific visit is used.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.CropTarget","title":"<code>CropTarget</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing different cropping targets for medical imaging.</p> <p>Attributes:</p> Name Type Description <code>ANATOMY</code> <code>int</code> <p>Crop to the anatomical structure (e.g., brain or breast)</p> <code>ROI_ENHANCE</code> <code>int</code> <p>Crop to the region of interest (ROI) for the enhancing region.</p> <code>ROI_NONENHANCE</code> <code>int</code> <p>Crop to the region of interest (ROI) for the non-enhancing region.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.ITKNifti","title":"<code>ITKNifti</code>","text":"<p>               Bases: <code>Image3D</code></p> <p>Placeholder class for ITK-based NIfTI handling.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D","title":"<code>Image3D</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Abstract base class for 3D medical images.</p> <p>Attributes:</p> Name Type Description <code>image</code> <code>Any</code> <p>The underlying image data (e.g., NIfTI image object).</p> <p>Methods:</p> Name Description <code>array</code> <p>Abstract property to get the image data as a NumPy array or PyTorch tensor.</p> <code>from_file</code> <p>Abstract method to load an image from a file.</p> <code>to_file</code> <p>Abstract method to save the image to a file.</p> <code>shape</code> <p>Abstract property to get the shape of the image.</p> <code>centroid</code> <p>Abstract property to get the centroid of the image.</p> <code>spacing</code> <p>Abstract property to get the voxel spacing of the image.</p> <code>voxvol</code> <p>Abstract property to calculate the volume of a voxel.</p> <code>from_array</code> <p>Abstract method to create an image from a NumPy array or PyTorch tensor.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D.array","title":"<code>array</code>  <code>property</code>","text":"<p>Returns the image data as a NumPy array or PyTorch tensor.</p> <p>Returns:</p> Type Description <code>ndarray | Tensor</code> <p>np.ndarray | torch.Tensor: The image data.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D.centroid","title":"<code>centroid</code>  <code>property</code>","text":"<p>Returns the centroid of the image.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The centroid coordinates.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Returns the shape of the image.</p> <p>Returns:</p> Name Type Description <code>Shape3D</code> <code>Shape3D</code> <p>The 3D shape of the image.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D.spacing","title":"<code>spacing</code>  <code>property</code>","text":"<p>Returns the voxel spacing of the image.</p> <p>Returns:</p> Name Type Description <code>Spacing3D</code> <code>Spacing3D</code> <p>The spacing along each axis and the unit of measurement.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D.voxvol","title":"<code>voxvol</code>  <code>property</code>","text":"<p>Calculates the volume of a voxel.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The voxel volume.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D.from_array","title":"<code>from_array(array, referenceImage)</code>  <code>staticmethod</code>","text":"<p>Creates a 3D image from a NumPy array or PyTorch tensor.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray | Tensor</code> <p>The array representing the image.</p> required <code>referenceImage</code> <code>Image3D</code> <p>An reference image for copying metadata.</p> required <p>Returns:</p> Name Type Description <code>Image3D</code> <code>Image3D</code> <p>The created 3D image.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D.from_file","title":"<code>from_file(path)</code>  <code>staticmethod</code>","text":"<p>Loads a 3D image from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>FilePath</code> <p>The path to the image file.</p> required <p>Returns:</p> Name Type Description <code>Image3D</code> <code>Image3D</code> <p>The loaded image.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Image3D.to_file","title":"<code>to_file(path)</code>","text":"<p>Saves the image to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>FilePath</code> <p>The destination file path.</p> required"},{"location":"api/types/imaging/#tumortwin.types.imaging.NibabelNifti","title":"<code>NibabelNifti</code>","text":"<p>               Bases: <code>Image3D</code></p> <p>Implementation of Image3D for NIfTI images using NiBabel.</p> <p>Attributes:</p> Name Type Description <code>image</code> <code>Nifti1Image</code> <p>The NIfTI image object.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.NibabelNifti.array","title":"<code>array</code>  <code>property</code>","text":"<p>Returns the image data as a NumPy array.</p> <p>Returns:</p> Type Description <code>ndarray | Tensor</code> <p>np.ndarray | torch.Tensor: The image data.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.NibabelNifti.centroid","title":"<code>centroid</code>  <code>property</code>","text":"<p>Returns the centroid of the image.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The centroid coordinates.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.NibabelNifti.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Returns the shape of the image.</p> <p>Returns:</p> Name Type Description <code>Shape3D</code> <code>Shape3D</code> <p>The 3D shape of the image.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.NibabelNifti.spacing","title":"<code>spacing</code>  <code>property</code>","text":"<p>Returns the voxel spacing of the image.</p> <p>Returns:</p> Name Type Description <code>Spacing3D</code> <code>Spacing3D</code> <p>The spacing along each axis and the unit of measurement.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.NibabelNifti.from_array","title":"<code>from_array(array, referenceImage=None)</code>  <code>staticmethod</code>","text":"<p>Creates a NIfTI image from a NumPy array or PyTorch tensor.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray | Tensor</code> <p>The array representing the image.</p> required <code>referenceImage</code> <code>Optional[NibabelNifti]</code> <p>An reference NIfTI image for copying metadata.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NibabelNifti</code> <code>NibabelNifti</code> <p>The created NIfTI image.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.NibabelNifti.from_file","title":"<code>from_file(path)</code>  <code>staticmethod</code>","text":"<p>Loads a NIfTI image from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>FilePath</code> <p>The path to the NIfTI file.</p> required <p>Returns:</p> Name Type Description <code>NibabelNifti</code> <code>NibabelNifti</code> <p>The loaded NIfTI image.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.NibabelNifti.to_file","title":"<code>to_file(path)</code>","text":"<p>Saves the NIfTI image to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>FilePath</code> <p>The destination file path.</p> required"},{"location":"api/types/imaging/#tumortwin.types.imaging.Shape3D","title":"<code>Shape3D</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Represents the 3D size/shape of an image or volume.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>int</code> <p>The size (i.e. number of points) along the x-axis.</p> <code>y</code> <code>int</code> <p>The size (i.e. number of points) along the y-axis.</p> <code>z</code> <code>int</code> <p>The size (i.e. number of points) along the z-axis.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Spacing3D","title":"<code>Spacing3D</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Represents the spacing between voxels in a 3D image or volume.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Spacing along the x-axis.</p> <code>y</code> <code>float</code> <p>Spacing along the y-axis.</p> <code>z</code> <code>float</code> <p>Spacing along the z-axis.</p> <code>unit</code> <code>Unit</code> <p>The unit of measurement for the spacing values.</p>"},{"location":"api/types/imaging/#tumortwin.types.imaging.Unit","title":"<code>Unit</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing units of measurement commonly used in medical imaging.</p> <p>Attributes:</p> Name Type Description <code>UNKNOWN</code> <code>int</code> <p>Unknown unit.</p> <code>METER</code> <code>int</code> <p>Unit of length in meters.</p> <code>MILLIMETER</code> <code>int</code> <p>Unit of length in millimeters.</p> <code>MICRON</code> <code>int</code> <p>Unit of length in microns.</p> <code>SECONDS</code> <code>int</code> <p>Unit of time in seconds.</p> <code>MILLISECONDS</code> <code>int</code> <p>Unit of time in milliseconds.</p> <code>MICROSECONDS</code> <code>int</code> <p>Unit of time in microseconds.</p> <code>HERTZ</code> <code>int</code> <p>Unit of frequency in hertz.</p> <code>PARTSPERMILLION</code> <code>int</code> <p>Unit for parts per million.</p> <code>RADIANSPERSECOND</code> <code>int</code> <p>Unit for angular velocity in radians per second.</p>"},{"location":"api/types/treatments/","title":"Treatments","text":""},{"location":"api/types/treatments/#tumortwin.types.treatment.ChemotherapyProtocol","title":"<code>ChemotherapyProtocol = Dict[TreatmentTime, float]</code>  <code>module-attribute</code>","text":"<p>Alias for a chemotherapy protocol, mapping treatment times to dose values.</p>"},{"location":"api/types/treatments/#tumortwin.types.treatment.RadiotherapyProtocol","title":"<code>RadiotherapyProtocol = Dict[TreatmentTime, float]</code>  <code>module-attribute</code>","text":"<p>Alias for a radiotherapy protocol, mapping treatment times to dose values.</p>"},{"location":"api/types/treatments/#tumortwin.types.treatment.TreatmentTime","title":"<code>TreatmentTime = datetime</code>  <code>module-attribute</code>","text":"<p>Alias for how the data type we choose to represent the time of a treatment.</p>"},{"location":"api/types/treatments/#tumortwin.types.treatment.ChemotherapySpecification","title":"<code>ChemotherapySpecification</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a chemotherapy treatment specification, including dose schedule and pharmacokinetic parameters.</p> <p>Attributes:</p> Name Type Description <code>sensitivity</code> <code>float</code> <p>The sensitivity parameter of the drug.</p> <code>decay_rate</code> <code>float</code> <p>The decay rate of the drug in the body.</p> <code>times</code> <code>List[datetime]</code> <p>Times of the treatments in the protocol.</p> <code>doses</code> <code>List[float]</code> <p>Doses corresponding to each treatment time.</p> <code>protocol(ChemotherapyProtocol)</code> <code>List[float]</code> <p>The complete mapping of treatment times to chemotherapy doses.</p>"},{"location":"api/types/treatments/#tumortwin.types.treatment.ChemotherapyTreatment","title":"<code>ChemotherapyTreatment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single chemotherapy treatment session.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>TreatmentTime</code> <p>The time of the treatment.</p> <code>dose</code> <code>float</code> <p>The dose delivered during the treatment.</p> <code>units</code> <code>ChemotherapyUnit</code> <p>The unit of the dose (e.g., mg).</p>"},{"location":"api/types/treatments/#tumortwin.types.treatment.ChemotherapyUnit","title":"<code>ChemotherapyUnit</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of possible units for chemotherapy doses.</p> <p>Attributes:</p> Name Type Description <code>mg</code> <code>str</code> <p>Milligrams, a unit of mass.</p>"},{"location":"api/types/treatments/#tumortwin.types.treatment.RadiotherapySpecification","title":"<code>RadiotherapySpecification</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a radiotherapy protocol, including dose schedule and biological parameters.</p> <p>Attributes:</p> Name Type Description <code>alpha</code> <code>float</code> <p>Tissue-specific radiosensitivity parameter (\u03b1).</p> <code>alpha_beta_ratio</code> <code>float</code> <p>Tissue-specific \u03b1/\u03b2 ratio.</p> <code>times</code> <code>List[TreatmentTime]</code> <p>Times of the treatments in the protocol.</p> <code>doses</code> <code>List[float]</code> <p>Doses corresponding to each treatment time.</p> <code>protocol(RadiotherapyProtocol)</code> <code>List[float]</code> <p>The complete mapping of treatment times to radiotherapy doses.</p>"},{"location":"api/types/treatments/#tumortwin.types.treatment.RadiotherapyTreatment","title":"<code>RadiotherapyTreatment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single radiotherapy treatment session.</p> <p>Attributes:</p> Name Type Description <code>time</code> <code>TreatmentTime</code> <p>The time of the treatment.</p> <code>dose</code> <code>float</code> <p>The dose delivered during the treatment.</p> <code>units</code> <code>RadiotherapyUnit</code> <p>The unit of the dose (e.g., Gy).</p>"},{"location":"api/types/treatments/#tumortwin.types.treatment.RadiotherapyUnit","title":"<code>RadiotherapyUnit</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of possible units for radiotherapy doses.</p> <p>Attributes:</p> Name Type Description <code>Gy</code> <code>str</code> <p>Gray, the SI unit of absorbed radiation dose.</p>"},{"location":"api/types/patient_data/hgg_types/","title":"HGG","text":""},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGPatientData","title":"<code>HGGPatientData</code>","text":"<p>               Bases: <code>BasePatientData</code></p> <p>Represents high-grade glioma (HGG) patient data.</p> <p>This model contains the patient-specific data, including imaging information, treatment history, and metadata. It provides methods to load patient data from files and compute derived properties, such as brain-masked images and treatment days.</p> <p>Attributes:</p> Name Type Description <code>model_config</code> <code>SettingsConfigDict</code> <p>Configuration for environment files.</p> <code>image_dir</code> <code>Optional[DirectoryPath]</code> <p>Path to the directory containing patient images. Hidden in representations.</p> <code>patient</code> <code>str</code> <p>Patient identifier.</p> <code>brainmask</code> <code>Path</code> <p>Path to the brain mask image file.</p> <code>crop_settings</code> <code>Optional[CropSettings]</code> <p>Settings object describing if and how to crop images. Defaults to <code>None</code> (no cropping).</p> <code>crop_bounding_box</code> <code>Optional[BoundingBoxIndices]</code> <p>Bounding box for cropping images, if available.</p> <code>T1_pre</code> <code>Optional[Path]</code> <p>Path to the pre-contrast T1-weighted image file.</p> <code>T1_post</code> <code>Optional[Path]</code> <p>Path to the post-contrast T1-weighted image file.</p> <code>T2_flair</code> <code>Optional[Path]</code> <p>Path to the T2 FLAIR image file.</p> <code>visits</code> <code>List[HGGVisitData]</code> <p>List of patient visits, including imaging and ROI data.</p> <code>radiotherapy</code> <code>List[RadiotherapyTreatment]</code> <p>List of radiotherapy treatments.</p> <code>chemotherapy</code> <code>List[ChemotherapyTreatment]</code> <p>List of chemotherapy treatments.</p>"},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGPatientData.T1_post_image","title":"<code>T1_post_image</code>  <code>property</code>","text":"<p>Loads the post-contrast T1-weighted image and optionally crops it.</p> <p>Returns:</p> Type Description <code>Optional[NibabelNifti]</code> <p>Optional[NibabelNifti]: The loaded T1-post image, or <code>None</code> if unavailable.</p>"},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGPatientData.T1_pre_image","title":"<code>T1_pre_image</code>  <code>property</code>","text":"<p>Loads the pre-contrast T1-weighted image and optionally crops it.</p> <p>Returns:</p> Type Description <code>Optional[NibabelNifti]</code> <p>Optional[NibabelNifti]: The loaded T1-pre image, or <code>None</code> if unavailable.</p>"},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGPatientData.T2_flair_image","title":"<code>T2_flair_image</code>  <code>property</code>","text":"<p>Loads the T2 FLAIR image and optionally crops it.</p> <p>Returns:</p> Type Description <code>Optional[NibabelNifti]</code> <p>Optional[NibabelNifti]: The loaded T2 FLAIR image, or <code>None</code> if unavailable.</p>"},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGPatientData.brainmask_image","title":"<code>brainmask_image</code>  <code>property</code>","text":"<p>Loads the brain mask image and optionally crops it to the brain bounding box.</p> <p>Returns:</p> Name Type Description <code>NibabelNifti</code> <code>NibabelNifti</code> <p>The loaded brain mask image.</p>"},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGVisitData","title":"<code>HGGVisitData</code>","text":"<p>               Bases: <code>BaseVisitData</code></p> <p>Represents data for a single patient visit in the context of high-grade glioma (HGG).</p> <p>Attributes:</p> Name Type Description <code>adc</code> <code>Path</code> <p>Path to the Apparent Diffusion Coefficient (ADC) image file.</p> <code>roi_enhance</code> <code>Path</code> <p>Path to the file containing the region of interest (ROI) for enhancing tumor regions.</p> <code>roi_nonenhance</code> <code>Path</code> <p>Path to the file containing the ROI for non-enhancing tumor regions.</p>"},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGVisitData.adc_image","title":"<code>adc_image</code>  <code>property</code>","text":"<p>Loads the ADC image as a NibabelNifti object, optionally cropped to the crop bounding box.</p> <p>Returns:</p> Name Type Description <code>NibabelNifti</code> <code>NibabelNifti</code> <p>The loaded and optionally cropped ADC image.</p>"},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGVisitData.roi_enhance_image","title":"<code>roi_enhance_image</code>  <code>property</code>","text":"<p>Loads the ROI enhancing image as a NibabelNifti object, optionally cropped to the brain region.</p> <p>Returns:</p> Name Type Description <code>NibabelNifti</code> <code>NibabelNifti</code> <p>The loaded and optionally cropped ROI enhancing image.</p>"},{"location":"api/types/patient_data/hgg_types/#tumortwin.types.hgg_data.HGGVisitData.roi_nonenhance_image","title":"<code>roi_nonenhance_image</code>  <code>property</code>","text":"<p>Loads the ROI non-enhancing image as a NibabelNifti object, optionally cropped to the brain region.</p> <p>Returns:</p> Name Type Description <code>NibabelNifti</code> <code>NibabelNifti</code> <p>The loaded and optionally cropped ROI non-enhancing image.</p>"},{"location":"api/types/patient_data/tnbc_types/","title":"TODO","text":""},{"location":"tutorials/Cropping_Demo/","title":"Cropping Demo","text":"In\u00a0[1]: Copied! <pre>import os\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nfrom pydantic import FilePath\n\nfrom tumortwin.preprocessing import ADC_to_cellularity\nfrom tumortwin.types import CropSettings, CropTarget, HGGPatientData\nfrom tumortwin.utils import find_best_slice\n\ntry:\n    patient_dir = os.environ.get(\"patient_dir\")\n    image_dir = os.environ.get(\"image_dir\")\n    assert patient_dir is not None\n    assert image_dir is not None\n    PATIENT_INFO_PATH = FilePath(patient_dir)\n    IMAGE_PATH = Path(image_dir)\nexcept:\n    raise ValueError(\"Missing environment variables! Check .env file\")\n</pre> import os from pathlib import Path  import matplotlib.pyplot as plt from pydantic import FilePath  from tumortwin.preprocessing import ADC_to_cellularity from tumortwin.types import CropSettings, CropTarget, HGGPatientData from tumortwin.utils import find_best_slice  try:     patient_dir = os.environ.get(\"patient_dir\")     image_dir = os.environ.get(\"image_dir\")     assert patient_dir is not None     assert image_dir is not None     PATIENT_INFO_PATH = FilePath(patient_dir)     IMAGE_PATH = Path(image_dir) except:     raise ValueError(\"Missing environment variables! Check .env file\") <p>Let's start by loading in the patient dataset. <code>crop_settings=None</code> (the default) will perform no cropping. Let's visualize the data by plotting a slice of the brain, and overlay the brain mask.</p> In\u00a0[2]: Copied! <pre>patient_data = HGGPatientData.from_file(\n    PATIENT_INFO_PATH, image_dir=IMAGE_PATH, crop_settings=None\n)\n\nvisit = patient_data.visits[0]\n\ncellularity = ADC_to_cellularity(\n    visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image\n)\n\nslice_idx = find_best_slice(cellularity.array)\n\nfig, ax = plt.subplots(1, 1)\nax.imshow(patient_data.T1_pre_image.array[:, :, slice_idx])\nax.contour(patient_data.brainmask_image.array[:, :, slice_idx], colors=\"red\")\nax.set_title(\"T1 image with brain mask outline\")\nprint(f\"Array size: {cellularity.array.shape}\")\nprint(f\"Number of elements: {cellularity.array.size}\")\nplt.show()\n\nfig, ax = plt.subplots(1, 1)\nax.imshow(cellularity.array[:, :, slice_idx])\nax.contour(patient_data.brainmask_image.array[:, :, slice_idx], colors=\"red\")\nax.contour(visit.roi_enhance_image.array[:, :, slice_idx], colors=\"blue\")\nax.set_title(\"Cellularity image with ROI mask outline\")\nprint(f\"Array size: {cellularity.array.shape}\")\nprint(f\"Number of elements: {cellularity.array.size}\")\n</pre> patient_data = HGGPatientData.from_file(     PATIENT_INFO_PATH, image_dir=IMAGE_PATH, crop_settings=None )  visit = patient_data.visits[0]  cellularity = ADC_to_cellularity(     visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image )  slice_idx = find_best_slice(cellularity.array)  fig, ax = plt.subplots(1, 1) ax.imshow(patient_data.T1_pre_image.array[:, :, slice_idx]) ax.contour(patient_data.brainmask_image.array[:, :, slice_idx], colors=\"red\") ax.set_title(\"T1 image with brain mask outline\") print(f\"Array size: {cellularity.array.shape}\") print(f\"Number of elements: {cellularity.array.size}\") plt.show()  fig, ax = plt.subplots(1, 1) ax.imshow(cellularity.array[:, :, slice_idx]) ax.contour(patient_data.brainmask_image.array[:, :, slice_idx], colors=\"red\") ax.contour(visit.roi_enhance_image.array[:, :, slice_idx], colors=\"blue\") ax.set_title(\"Cellularity image with ROI mask outline\") print(f\"Array size: {cellularity.array.shape}\") print(f\"Number of elements: {cellularity.array.size}\") <pre>Array size: (90, 116, 36)\nNumber of elements: 375840\n</pre> <pre>Array size: (90, 116, 36)\nNumber of elements: 375840\n</pre> <p>This image is from an atlas, so has already been cropped to the brain region. In general this will not be the case, so we can perform cropping by setting the <code>CropSettings</code> object to have <code>crop_to=CropTarget.ANATOMY</code>:</p> In\u00a0[3]: Copied! <pre>patient_data_brain_crop = HGGPatientData.from_file(\n    PATIENT_INFO_PATH,\n    image_dir=IMAGE_PATH,\n    crop_settings=CropSettings(crop_to=CropTarget.ANATOMY),\n)\nvisit = patient_data_brain_crop.visits[0]\n\ncellularity_brain_crop = ADC_to_cellularity(\n    visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image\n)\n\nfig, ax = plt.subplots(1, 1)\nax.imshow(cellularity_brain_crop.array[:, :, slice_idx])\nax.contour(patient_data_brain_crop.brainmask_image.array[:, :, slice_idx], colors=\"red\")\nax.contour(visit.roi_enhance_image.array[:, :, slice_idx], colors=\"blue\")\nax.set_title(\"Cropped to brain\")\nprint(f\"Array size after cropping to brain: {cellularity_brain_crop.array.shape}\")\nprint(f\"Number of elements: {cellularity_brain_crop.array.size}\")\nprint(\n    f\"Reduction in number of elements: {(1 - (cellularity_brain_crop.array.size / cellularity.array.size))*100:.1f}%\"\n)\n</pre> patient_data_brain_crop = HGGPatientData.from_file(     PATIENT_INFO_PATH,     image_dir=IMAGE_PATH,     crop_settings=CropSettings(crop_to=CropTarget.ANATOMY), ) visit = patient_data_brain_crop.visits[0]  cellularity_brain_crop = ADC_to_cellularity(     visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image )  fig, ax = plt.subplots(1, 1) ax.imshow(cellularity_brain_crop.array[:, :, slice_idx]) ax.contour(patient_data_brain_crop.brainmask_image.array[:, :, slice_idx], colors=\"red\") ax.contour(visit.roi_enhance_image.array[:, :, slice_idx], colors=\"blue\") ax.set_title(\"Cropped to brain\") print(f\"Array size after cropping to brain: {cellularity_brain_crop.array.shape}\") print(f\"Number of elements: {cellularity_brain_crop.array.size}\") print(     f\"Reduction in number of elements: {(1 - (cellularity_brain_crop.array.size / cellularity.array.size))*100:.1f}%\" ) <pre>Array size after cropping to brain: (90, 116, 36)\nNumber of elements: 375840\nReduction in number of elements: 0.0%\n</pre> <p>Sometimes, if the tumor only occupies a small region in the brain, we may not want to include the entire brain in our computational domain. Instead, we may like to use only a region-of-interest (ROI), potentially with additional padding to allow for some amount of future tumor growth outside the ROI.</p> <p>We can achieve this by using <code>crop_settings = CropSettings(crop_to = CropTarget.ROI_ENHANCE, padding = 0, visit_index = -1)</code> Note that the visit_index is used to specify which imaging visit's ROI to use. You would typically choose the largest ROI - here we use <code>-1</code>, the last visit, since this particular tumor is growing in time. For a shrinking tumor you might choose <code>visit_index = 0</code>.</p> In\u00a0[4]: Copied! <pre>patient_data_roi_crop = HGGPatientData.from_file(\n    PATIENT_INFO_PATH,\n    image_dir=IMAGE_PATH,\n    crop_settings=CropSettings(\n        crop_to=CropTarget.ROI_ENHANCE, padding=0, visit_index=-1\n    ),\n)\nvisit = patient_data_roi_crop.visits[patient_data_roi_crop.crop_settings.visit_index]\n\ncellularity_roi_crop = ADC_to_cellularity(\n    visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image\n)\n\nfig, ax = plt.subplots(1, 1)\nax.imshow(cellularity_roi_crop.array[:, :, slice_idx])\nax.contour(visit.roi_enhance_image.array[:, :, slice_idx], colors=\"red\")\nax.set_title(\"Cropped to ROI\")\nprint(f\"Array size after cropping to ROI: {cellularity_roi_crop.array.shape}\")\nprint(f\"Number of elements: {cellularity_roi_crop.array.size}\")\nprint(\n    f\"Reduction in number of elements: {(1 - (cellularity_roi_crop.array.size / cellularity.array.size))*100:.1f}%\"\n)\n</pre> patient_data_roi_crop = HGGPatientData.from_file(     PATIENT_INFO_PATH,     image_dir=IMAGE_PATH,     crop_settings=CropSettings(         crop_to=CropTarget.ROI_ENHANCE, padding=0, visit_index=-1     ), ) visit = patient_data_roi_crop.visits[patient_data_roi_crop.crop_settings.visit_index]  cellularity_roi_crop = ADC_to_cellularity(     visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image )  fig, ax = plt.subplots(1, 1) ax.imshow(cellularity_roi_crop.array[:, :, slice_idx]) ax.contour(visit.roi_enhance_image.array[:, :, slice_idx], colors=\"red\") ax.set_title(\"Cropped to ROI\") print(f\"Array size after cropping to ROI: {cellularity_roi_crop.array.shape}\") print(f\"Number of elements: {cellularity_roi_crop.array.size}\") print(     f\"Reduction in number of elements: {(1 - (cellularity_roi_crop.array.size / cellularity.array.size))*100:.1f}%\" ) <pre>Array size after cropping to ROI: (62, 105, 34)\nNumber of elements: 221340\nReduction in number of elements: 41.1%\n</pre>"},{"location":"tutorials/Cropping_Demo/#cropping-demo","title":"Cropping Demo\u00b6","text":"<p>This demo showcases how to crop images to either anatomic (e.g. brain, breast) or region-of-interest (ROI) masks using <code>TumorTwin</code>.</p>"},{"location":"tutorials/Cropping_Demo/#conclusion","title":"Conclusion:\u00b6","text":"<p>This demonstrates the <code>TumorTwin</code> cropping functionality. Since the computational domain is three-dimensional, cropping to only the relevant region can greatly reduce the number of degrees of freedom in the solution domain, leading to large computational savings.</p>"},{"location":"tutorials/HGG_Demo/","title":"High-grade glioma (HGG) Demo","text":"In\u00a0[40]: Copied! <pre># Set up google colab environment (if running in colab)\nimport sys\nimport importlib.util\nimport os\nfrom pathlib import Path\n\nif 'google.colab' in sys.modules:\n    !pip uninstall -y torchvision torchaudio thinc fastai\n\n    # Helper function to check if a package is installed\n    def is_package_installed(package_name):\n        return importlib.util.find_spec(package_name) is not None\n\n    # Only install TumorTwin if it's not already installed\n    if not is_package_installed(\"tumortwin\"):\n        !pip install git+https://github.com/OncologyModelingGroup/TumorTwin\n\n    # Only download and extract data if it doesn't already exist\n    data_path = Path(\"../input_files/HGG_demo_001\")\n    if not data_path.exists():\n        !wget https://github.com/OncologyModelingGroup/TumorTwin/raw/refs/heads/main/input_files/HGG_demo_001.tar.gz\n        !tar -xzvf HGG_demo_001.tar.gz\n        !mkdir -p ../input_files\n        !mv HGG_demo_001 ../input_files/HGG_demo_001\n</pre> # Set up google colab environment (if running in colab) import sys import importlib.util import os from pathlib import Path  if 'google.colab' in sys.modules:     !pip uninstall -y torchvision torchaudio thinc fastai      # Helper function to check if a package is installed     def is_package_installed(package_name):         return importlib.util.find_spec(package_name) is not None      # Only install TumorTwin if it's not already installed     if not is_package_installed(\"tumortwin\"):         !pip install git+https://github.com/OncologyModelingGroup/TumorTwin      # Only download and extract data if it doesn't already exist     data_path = Path(\"../input_files/HGG_demo_001\")     if not data_path.exists():         !wget https://github.com/OncologyModelingGroup/TumorTwin/raw/refs/heads/main/input_files/HGG_demo_001.tar.gz         !tar -xzvf HGG_demo_001.tar.gz         !mkdir -p ../input_files         !mv HGG_demo_001 ../input_files/HGG_demo_001 In\u00a0[2]: Copied! <pre>## Imports...\nimport os\nfrom datetime import timedelta\nfrom pathlib import Path\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom pydantic import FilePath\nfrom rich import print\n\nfrom tumortwin.models import ReactionDiffusion3D\nfrom tumortwin.optimizers import LMoptimizer, LMoptions\nfrom tumortwin.postprocessing import (\n    compute_total_cell_count,\n    plot_calibration,\n    plot_calibration_iter,\n    plot_cellularity_map,\n    plot_imaging_summary,\n    plot_loss,\n    plot_measured_TCC,\n    plot_patient_timeline,\n    plot_predicted_TCC,\n)\nfrom tumortwin.preprocessing import ADC_to_cellularity, compute_carrying_capacity\nfrom tumortwin.solvers import TorchDiffEqSolver, TorchDiffEqSolverOptions\nfrom tumortwin.types import (\n    ChemotherapySpecification,\n    CropSettings,\n    CropTarget,\n    RadiotherapySpecification,\n)\nfrom tumortwin.types.hgg_data import HGGPatientData\nfrom tumortwin.utils import daterange, days_since_first\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n%matplotlib inline\nfont = {\n    \"weight\": \"normal\",\n    \"size\": 10,\n}\nmatplotlib.rc(\"font\", **font)\nmatplotlib.rc(\"figure\", dpi=300)\nmatplotlib.rc(\"savefig\", dpi=300)\n</pre> ## Imports... import os from datetime import timedelta from pathlib import Path  import matplotlib import matplotlib.pyplot as plt import numpy as np import torch from pydantic import FilePath from rich import print  from tumortwin.models import ReactionDiffusion3D from tumortwin.optimizers import LMoptimizer, LMoptions from tumortwin.postprocessing import (     compute_total_cell_count,     plot_calibration,     plot_calibration_iter,     plot_cellularity_map,     plot_imaging_summary,     plot_loss,     plot_measured_TCC,     plot_patient_timeline,     plot_predicted_TCC, ) from tumortwin.preprocessing import ADC_to_cellularity, compute_carrying_capacity from tumortwin.solvers import TorchDiffEqSolver, TorchDiffEqSolverOptions from tumortwin.types import (     ChemotherapySpecification,     CropSettings,     CropTarget,     RadiotherapySpecification, ) from tumortwin.types.hgg_data import HGGPatientData from tumortwin.utils import daterange, days_since_first  device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")  %matplotlib inline font = {     \"weight\": \"normal\",     \"size\": 10, } matplotlib.rc(\"font\", **font) matplotlib.rc(\"figure\", dpi=300) matplotlib.rc(\"savefig\", dpi=300) <p>Here we load in the input dataset. You will need to ensure that you have a <code>.env</code> file with the relevant paths set:</p> <pre><code>image_dir = path_to_image_folder\npatient_dir = path_to_patient_json\n</code></pre> In\u00a0[26]: Copied! <pre>PATIENT_INFO_PATH = FilePath(\"../input_files/HGG_demo_001/HGG_demo_001.json\")\nIMAGE_PATH = FilePath(\"../input_files/HGG_demo_001\")\ncrop_settings = CropSettings(crop_to=CropTarget.ROI_ENHANCE, padding=10, visit_index=-1)\npatient_data = HGGPatientData.from_file(\n    PATIENT_INFO_PATH, image_dir=IMAGE_PATH, crop_settings=crop_settings\n)\n</pre> PATIENT_INFO_PATH = FilePath(\"../input_files/HGG_demo_001/HGG_demo_001.json\") IMAGE_PATH = FilePath(\"../input_files/HGG_demo_001\") crop_settings = CropSettings(crop_to=CropTarget.ROI_ENHANCE, padding=10, visit_index=-1) patient_data = HGGPatientData.from_file(     PATIENT_INFO_PATH, image_dir=IMAGE_PATH, crop_settings=crop_settings ) In\u00a0[27]: Copied! <pre>plot_patient_timeline(patient_data)\n</pre> plot_patient_timeline(patient_data) <p>We can also plot a summary of the imaging data. Here you should verify that the images are aligned/registered, cropped appropriately, and that the anatomic (T1), apparent diffusion coefficient (ADC), and region-of-interest (ROI) images are as expected.</p> In\u00a0[28]: Copied! <pre>plot_imaging_summary(patient_data)\n</pre> plot_imaging_summary(patient_data) In\u00a0[29]: Copied! <pre>measured_cellularity_maps = [\n    ADC_to_cellularity(\n        visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image\n    )\n    for visit in patient_data.visits\n]\n</pre> measured_cellularity_maps = [     ADC_to_cellularity(         visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image     )     for visit in patient_data.visits ] In\u00a0[30]: Copied! <pre>k = torch.tensor(0.05, requires_grad=True, device=device)\nd = torch.tensor(0.025, requires_grad=True, device=device)\ntheta = torch.tensor(1.0, requires_grad=False, device=device)\n</pre> k = torch.tensor(0.05, requires_grad=True, device=device) d = torch.tensor(0.025, requires_grad=True, device=device) theta = torch.tensor(1.0, requires_grad=False, device=device) <p>Radiotherapy parameters:</p> <ul> <li>$\\alpha_{RT}$ : Radiosensitivity parameter, see <code>RadiotherapySpecification.alpha</code></li> <li>$\\beta_{RT}$: : Radiosensitivity parameter, often defined relative to $\\alpha$, see <code>RadiotherapySpecification.alpha_beta_ratio</code></li> <li>$d_{RT}$ : Radiotherapy dosage</li> </ul> <p>Here we set up a <code>RadiotherapySpecification</code> for this patient. We use the treatment plan (times and dosages) that we loaded the patient json file, which are now stored within the <code>HGGPatientData</code> object:</p> In\u00a0[31]: Copied! <pre>rt = RadiotherapySpecification(\n    alpha=0.025,\n    alpha_beta_ratio=10,\n    times=[r.time for r in patient_data.radiotherapy],\n    doses=[r.dose for r in patient_data.radiotherapy],\n)\n# print(rt)\n</pre> rt = RadiotherapySpecification(     alpha=0.025,     alpha_beta_ratio=10,     times=[r.time for r in patient_data.radiotherapy],     doses=[r.dose for r in patient_data.radiotherapy], ) # print(rt) <p>Chemotherapy parameters:</p> <p>Note: Here we are working with only one chemotherapy drug, so $n_{\\text{CT}}=1$</p> <ul> <li>$\\alpha_{1}$ : Chemotherapy sensitivity parameter, see <code>ChemotherapySpecification.sensitivty</code></li> <li>$\\beta_{1}$: : Chemotherapy decay rate, see <code>ChemotherapySpecification.decay_rate</code></li> <li>$C_{1}(d_{CT},t)$ : Chemotherapy drug concentration, which depends on the dosage given, and time since dosage was given.</li> </ul> <p>We can set up a <code>ChemotherapySpecification</code> in a similar way, using the treatment plan (times and dosages) that we loaded from the patient json file, which are now stored within the <code>HGGPatientData</code> object:</p> In\u00a0[32]: Copied! <pre>ct = ChemotherapySpecification(\n    sensitivity=0.5,\n    decay_rate=9.2420,\n    times=[c.time for c in patient_data.chemotherapy],\n    doses=[c.dose for c in patient_data.chemotherapy],\n)\n# print(ct)\n</pre> ct = ChemotherapySpecification(     sensitivity=0.5,     decay_rate=9.2420,     times=[c.time for c in patient_data.chemotherapy],     doses=[c.dose for c in patient_data.chemotherapy], ) # print(ct) <p>Finally, we can set up the <code>ReactionDiffusion3D</code> model object.</p> In\u00a0[33]: Copied! <pre>model = ReactionDiffusion3D(\n    k=k,\n    d=d,\n    theta=theta,\n    patient_data=patient_data,\n    initial_time=patient_data.visits[0].time,\n    chemotherapy_specifications=[ct],\n    radiotherapy_specification=rt,\n)\n</pre> model = ReactionDiffusion3D(     k=k,     d=d,     theta=theta,     patient_data=patient_data,     initial_time=patient_data.visits[0].time,     chemotherapy_specifications=[ct],     radiotherapy_specification=rt, ) In\u00a0[34]: Copied! <pre>solver_options = TorchDiffEqSolverOptions(\n    step_size=timedelta(days=0.5),\n    use_adjoint=True,\n    device=device,\n    method=\"rk4\",\n)\n\nsolver = TorchDiffEqSolver(model, solver_options)\n</pre> solver_options = TorchDiffEqSolverOptions(     step_size=timedelta(days=0.5),     use_adjoint=True,     device=device,     method=\"rk4\", )  solver = TorchDiffEqSolver(model, solver_options) In\u00a0[35]: Copied! <pre>timepoints = daterange(\n    patient_data.visits[0].time, patient_data.visits[-1].time, timedelta(days=0.5)\n)\nu0 = torch.from_numpy(measured_cellularity_maps[0].array)\n\ntimes, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)\n</pre> timepoints = daterange(     patient_data.visits[0].time, patient_data.visits[-1].time, timedelta(days=0.5) ) u0 = torch.from_numpy(measured_cellularity_maps[0].array)  times, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0) <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> In\u00a0[36]: Copied! <pre># brain_mask = torch.from_numpy(patient_data.brainmask_image.array)\n\nfig, ax = plt.subplots(1, 1, figsize=(5, 2))\nplot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax)\n\nfig, axes = plt.subplots(1, 5, figsize=(5, 2))\nfor i, t in enumerate([0, 50, 100, 150, 200]):\n    time_days = np.array([days_since_first(t, timepoints[0]) for t in timepoints])\n    t_idx = np.where(time_days == t)[0][0]\n    plot_cellularity_map(\n        predicted_cellularity_maps[t_idx], patient_data, time=t, ax=axes[i]\n    )\n</pre> # brain_mask = torch.from_numpy(patient_data.brainmask_image.array)  fig, ax = plt.subplots(1, 1, figsize=(5, 2)) plot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax)  fig, axes = plt.subplots(1, 5, figsize=(5, 2)) for i, t in enumerate([0, 50, 100, 150, 200]):     time_days = np.array([days_since_first(t, timepoints[0]) for t in timepoints])     t_idx = np.where(time_days == t)[0][0]     plot_cellularity_map(         predicted_cellularity_maps[t_idx], patient_data, time=t, ax=axes[i]     ) In\u00a0[37]: Copied! <pre>carrying_capacity = compute_carrying_capacity(patient_data.brainmask_image)\nfinal_tumor_cell_count = compute_total_cell_count(\n    predicted_cellularity_maps[-1], carrying_capacity\n)\nprint(final_tumor_cell_count)\n</pre> carrying_capacity = compute_carrying_capacity(patient_data.brainmask_image) final_tumor_cell_count = compute_total_cell_count(     predicted_cellularity_maps[-1], carrying_capacity ) print(final_tumor_cell_count) <pre>Warning: Units of input image are UNKNOWN. Defaulting to mm.\n</pre> <pre>tensor(1.4133e+11, dtype=torch.float64, grad_fn=&lt;MulBackward0&gt;)\n</pre> <p>To compute the gradients, we need to run a backwards (adjoint) solve. We can do this using the standard <code>PyTorch</code> approach of calling <code>.backward()</code> on the final tumor_cell_count to populate the gradients.</p> In\u00a0[38]: Copied! <pre>final_tumor_cell_count.backward()\n\nk_grad = model.k.grad\nprint(f\"Gradient of the final TCC w.r.t proliferation rate: {k_grad}\")\n\nd_grad = model.d.grad\nprint(f\"Gradient of the final TCC w.r.t diffusion rate: {d_grad}\")\n</pre> final_tumor_cell_count.backward()  k_grad = model.k.grad print(f\"Gradient of the final TCC w.r.t proliferation rate: {k_grad}\")  d_grad = model.d.grad print(f\"Gradient of the final TCC w.r.t diffusion rate: {d_grad}\") <pre>Gradient of the final TCC w.r.t proliferation rate: 5402783645696.0\n</pre> <pre>Gradient of the final TCC w.r.t diffusion rate: 1168585261056.0\n</pre> In\u00a0[39]: Copied! <pre># plot TCC vs. time for predictions and measurements\nfig, ax = plt.subplots(1, 1, figsize=(5,2))\nplot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax)\nplot_measured_TCC(\n    [m.array for m in measured_cellularity_maps],\n    [v.time for v in patient_data.visits],\n    ax=ax,\n)\nax.legend([\"predicted\", \"measured\"]);\n\n# plot cellularity maps for predictions and measurements\nfig, axs = plt.subplots(2, len(patient_data.visit_days[::2]), figsize=(5,2))\nfor i, t in enumerate(patient_data.visit_days[::2]):\n    time_days = np.array([days_since_first(t, timepoints[0]) for t in timepoints])\n    t_idx = np.where(time_days == t)[0][0]\n    plot_cellularity_map(\n        predicted_cellularity_maps[t_idx], patient_data, time=t, ax=axs[0,i]\n    )\n    plot_cellularity_map(\n        torch.tensor(measured_cellularity_maps[2*i].array), patient_data, time=t, ax=axs[1,i]\n    )\naxs[0,0].set_ylabel('Predicted')\naxs[1,0].set_ylabel('Measured');\n</pre> # plot TCC vs. time for predictions and measurements fig, ax = plt.subplots(1, 1, figsize=(5,2)) plot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax) plot_measured_TCC(     [m.array for m in measured_cellularity_maps],     [v.time for v in patient_data.visits],     ax=ax, ) ax.legend([\"predicted\", \"measured\"]);  # plot cellularity maps for predictions and measurements fig, axs = plt.subplots(2, len(patient_data.visit_days[::2]), figsize=(5,2)) for i, t in enumerate(patient_data.visit_days[::2]):     time_days = np.array([days_since_first(t, timepoints[0]) for t in timepoints])     t_idx = np.where(time_days == t)[0][0]     plot_cellularity_map(         predicted_cellularity_maps[t_idx], patient_data, time=t, ax=axs[0,i]     )     plot_cellularity_map(         torch.tensor(measured_cellularity_maps[2*i].array), patient_data, time=t, ax=axs[1,i]     ) axs[0,0].set_ylabel('Predicted') axs[1,0].set_ylabel('Measured'); <p>Not very good! We see that our model is significantly under-predicting the size/intensity of the tumor.</p> <ul> <li>Perhaps this patient has a more aggressive tumor? We could try increasing the tumor proliferation rate, $k$, or the diffusion rate $d$?</li> <li>Perhaps they are not responding to treatment as well as we thought? We could try reducing the radiosensitivity or chemosensitivity parameters, $\\alpha$?</li> </ul> In\u00a0[17]: Copied! <pre># How many imaging dates do we want to try and match\nn_visits_calibration = 5  # *Including* the initial visit\n\ntarget_timepoints = [visit.time for visit in patient_data.visits[:n_visits_calibration]]\ntarget_solution = torch.stack(\n    tuple(\n        [\n            torch.from_numpy(m.array)\n            for m in measured_cellularity_maps[: n_visits_calibration]\n        ]\n    )\n)\n</pre> # How many imaging dates do we want to try and match n_visits_calibration = 5  # *Including* the initial visit  target_timepoints = [visit.time for visit in patient_data.visits[:n_visits_calibration]] target_solution = torch.stack(     tuple(         [             torch.from_numpy(m.array)             for m in measured_cellularity_maps[: n_visits_calibration]         ]     ) ) <p>Next we create a helper function for the optimizer. This function simply takes a set of parameter values, updates the model with these parameter values, runs a forward solve, and outputs the solution at the target timepoints.</p> In\u00a0[18]: Copied! <pre>def update_model_and_predict(model_parameters, timepoints = target_timepoints):\n    d, k, alpha, ct_sens = torch.nn.Parameter(model_parameters)\n    solver.model.d = torch.nn.Parameter(d)\n    solver.model.k = torch.nn.Parameter(k)\n    solver.model.radiotherapy_specification.alpha = torch.nn.Parameter(alpha)\n    solver.model.chemotherapy_specifications[0].sensitivity = torch.nn.Parameter(ct_sens)\n\n    _, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)\n    return predicted_cellularity_maps\n</pre> def update_model_and_predict(model_parameters, timepoints = target_timepoints):     d, k, alpha, ct_sens = torch.nn.Parameter(model_parameters)     solver.model.d = torch.nn.Parameter(d)     solver.model.k = torch.nn.Parameter(k)     solver.model.radiotherapy_specification.alpha = torch.nn.Parameter(alpha)     solver.model.chemotherapy_specifications[0].sensitivity = torch.nn.Parameter(ct_sens)      _, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)     return predicted_cellularity_maps In\u00a0[19]: Copied! <pre>initial_parameters = torch.tensor((0.025, 0.05, 0.025, 0.5))\noptions = LMoptions()\noptim = LMoptimizer(\n    model=update_model_and_predict,\n    initial_guess=initial_parameters,\n    bounds=torch.tensor(((0.0, 2), (0.0, 0.5), (0.001, 0.1), (0.0, 1.0))),\n    y_data=target_solution,\n    options=options,\n)\n</pre> initial_parameters = torch.tensor((0.025, 0.05, 0.025, 0.5)) options = LMoptions() optim = LMoptimizer(     model=update_model_and_predict,     initial_guess=initial_parameters,     bounds=torch.tensor(((0.0, 2), (0.0, 0.5), (0.001, 0.1), (0.0, 1.0))),     y_data=target_solution,     options=options, ) In\u00a0[20]: Copied! <pre># Run optimization for n_iter steps\nn_iter = 20\n\nfor i in range(n_iter):\n    print(\"Optimization Step: \" + str(i+1) +\"/\"+str(n_iter))\n    optim.step()\n\nbest_parameters = optim.parameters[-1]\nprint(\"Best parameters: \", best_parameters)\n</pre> # Run optimization for n_iter steps n_iter = 20  for i in range(n_iter):     print(\"Optimization Step: \" + str(i+1) +\"/\"+str(n_iter))     optim.step()  best_parameters = optim.parameters[-1] print(\"Best parameters: \", best_parameters) <pre>Optimization Step: 1/20\n</pre> <pre>Initial step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>/Users/mkapteyn/dev/tumortwin/venv/lib/python3.12/site-packages/tumortwin/optimizers/lm_optimizer.py:285: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).\n  return torch.tensor((deltaY - self.y) / delta, dtype=torch.float64)\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>/Users/mkapteyn/dev/tumortwin/venv/lib/python3.12/site-packages/tumortwin/optimizers/lm_optimizer.py:303: UserWarning: The use of `x.T` on tensors of dimension other than 2 to reverse their shape is deprecated and it will throw an error in a future release. Consider `x.mT` to transpose batches of matrices or `x.permute(*torch.arange(x.ndim - 1, -1, -1))` to reverse the dimensions of a tensor. (Triggered internally at /Users/runner/work/pytorch/pytorch/pytorch/aten/src/ATen/native/TensorShape.cpp:3641.)\n  e = solution_deltas.T @ solution_deltas\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 2/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 3/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 4/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 5/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 6/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 7/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 8/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 9/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 10/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 11/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 12/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 13/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 14/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 15/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 16/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 17/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 18/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 19/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 20/20\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-03-15 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Best parameters:  tensor([0.1000, 0.0500, 0.0500, 0.2001], dtype=torch.float64,\n       grad_fn=&lt;CopySlices&gt;)\n</pre> In\u00a0[21]: Copied! <pre>n_opt_viz = 2\nsols = []\nfor params in optim.parameters[::n_opt_viz]:\n    predicted_cellularity_maps = update_model_and_predict(params, timepoints)\n    sols.append(predicted_cellularity_maps)\n</pre> n_opt_viz = 2 sols = [] for params in optim.parameters[::n_opt_viz]:     predicted_cellularity_maps = update_model_and_predict(params, timepoints)     sols.append(predicted_cellularity_maps) <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <p>Now we plot the solutions visited by the optimizer, along with the corresponding loss (sum-of-squares error) values:</p> In\u00a0[22]: Copied! <pre>fig, ax =plt.subplots(1,1, figsize=(5,2))\nplot_calibration_iter(\n    sols, carrying_capacity, timepoints, measured_cellularity_maps, patient_data, t_calibration_end=target_timepoints[-1], ax=ax\n)\n\nfig, ax =plt.subplots(1,1, figsize=(5,2))\nplot_loss(torch.tensor(optim.error), ax=ax)\n</pre> fig, ax =plt.subplots(1,1, figsize=(5,2)) plot_calibration_iter(     sols, carrying_capacity, timepoints, measured_cellularity_maps, patient_data, t_calibration_end=target_timepoints[-1], ax=ax )  fig, ax =plt.subplots(1,1, figsize=(5,2)) plot_loss(torch.tensor(optim.error), ax=ax) <p>For this particular dataset, we know what the ground-truth parameter values are since we used them to generate the data! Of course, in a real scenario you wouldn't know what the \"true\" parameters are. In fact, the data might not exactly match the model for any value of the parameters.</p> <p>Ideally, our calibrated parameter values will be close to these, so let's compute the relative error in each parameter:</p> In\u00a0[23]: Copied! <pre>true_parameters = torch.tensor((0.1, 0.05, 0.05, 0.2))\nfinal_parameters = optim.parameters[-1]\n\n\ndef relative_error(estimate, truth):\n    return (100*abs(truth-estimate)/truth).round(decimals=4)\n\n\nprint(f\"Error in k: {relative_error(final_parameters[0], true_parameters[0])}%\")\nprint(f\"Error in d: {relative_error(final_parameters[1], true_parameters[1])}%\")\nprint(f\"Error in alpha: {relative_error(final_parameters[2], true_parameters[2])}%\")\nprint(f\"Error in ct_sens: {relative_error(final_parameters[3], true_parameters[3])}%\")\n</pre> true_parameters = torch.tensor((0.1, 0.05, 0.05, 0.2)) final_parameters = optim.parameters[-1]   def relative_error(estimate, truth):     return (100*abs(truth-estimate)/truth).round(decimals=4)   print(f\"Error in k: {relative_error(final_parameters[0], true_parameters[0])}%\") print(f\"Error in d: {relative_error(final_parameters[1], true_parameters[1])}%\") print(f\"Error in alpha: {relative_error(final_parameters[2], true_parameters[2])}%\") print(f\"Error in ct_sens: {relative_error(final_parameters[3], true_parameters[3])}%\") <pre>Error in k: 0.0021%\n</pre> <pre>Error in d: 0.0007%\n</pre> <pre>Error in alpha: 0.006%\n</pre> <pre>Error in ct_sens: 0.0302%\n</pre> In\u00a0[24]: Copied! <pre>def update_ct_total_dose(ct : ChemotherapySpecification, total_dose : float):\n    current_total_dose : float = np.sum(np.array(ct.doses))\n    additional_dose = total_dose - current_total_dose\n\n    adjuvant_total_dose = np.sum(ct.doses[49:])\n    dose_multiplier = (additional_dose+adjuvant_total_dose) / adjuvant_total_dose\n    ct.doses[49:] = [d*dose_multiplier for d in ct.doses[49:]]\n    return ct\n</pre> def update_ct_total_dose(ct : ChemotherapySpecification, total_dose : float):     current_total_dose : float = np.sum(np.array(ct.doses))     additional_dose = total_dose - current_total_dose      adjuvant_total_dose = np.sum(ct.doses[49:])     dose_multiplier = (additional_dose+adjuvant_total_dose) / adjuvant_total_dose     ct.doses[49:] = [d*dose_multiplier for d in ct.doses[49:]]     return ct <p>Now let's predict the tumor response for a range of total dosages, and plot the results:</p> In\u00a0[25]: Copied! <pre>sols = []\ncandidate_doses = [30, 40, 50, 60, 70]\n\nfig, ax = plt.subplots(1, 1, figsize=(5, 2))\nfor ct_total_dose in candidate_doses:\n    update_ct_total_dose(ct, ct_total_dose)\n    solver.model.chemotherapy_specifications = [ct]\n    print(f\"Running forward solve with total dose = {ct_total_dose}\")\n    times, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)\n    plot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax, alpha= 0.25 + 0.75*(ct_total_dose-min(candidate_doses))/(max(candidate_doses)-min(candidate_doses)))\n\nax.legend([\"Total dose: \"+str(d) for d in candidate_doses]);\n</pre> sols = [] candidate_doses = [30, 40, 50, 60, 70]  fig, ax = plt.subplots(1, 1, figsize=(5, 2)) for ct_total_dose in candidate_doses:     update_ct_total_dose(ct, ct_total_dose)     solver.model.chemotherapy_specifications = [ct]     print(f\"Running forward solve with total dose = {ct_total_dose}\")     times, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)     plot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax, alpha= 0.25 + 0.75*(ct_total_dose-min(candidate_doses))/(max(candidate_doses)-min(candidate_doses)))  ax.legend([\"Total dose: \"+str(d) for d in candidate_doses]); <pre>Running forward solve with total dose = 30\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Running forward solve with total dose = 40\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Running forward solve with total dose = 50\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Running forward solve with total dose = 60\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Running forward solve with total dose = 70\n</pre> <pre>Forward Simulation: [1996-11-15 00:00:00 to 1997-08-12 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre>"},{"location":"tutorials/HGG_Demo/#high-grade-glioma-hgg-demo","title":"High-grade glioma (HGG) Demo\u00b6","text":"<p>This demo showcases an end-to-end image-guided digital twin workflow with <code>TumorTwin</code>.</p>"},{"location":"tutorials/HGG_Demo/#table-of-contents","title":"\ud83d\udcda Table of Contents\u00b6","text":"<ul> <li>Step 1: Data Loading</li> <li>Step 2: Create Tumor Growth Model</li> <li>Step 3: Create a Solver object</li> <li>Step 4: Make a prediction</li> <li>Step 5 (Optional): Compute a quantity of interest and its gradient</li> <li>Step 6: Compare the model prediction to patient data</li> <li>Step 7: Calibrate the model to patient data via numerical optimization</li> <li>Step 8: Predict patient response under alternative treatment plan</li> <li>Conclusion</li> </ul>"},{"location":"tutorials/HGG_Demo/#step-1-data-loading","title":"Step 1: Data Loading\u00b6","text":""},{"location":"tutorials/HGG_Demo/#create-patientdata-object","title":"Create PatientData object\u00b6","text":""},{"location":"tutorials/HGG_Demo/#visualize-the-data","title":"Visualize the data\u00b6","text":"<p>We can visually verify that the dataset has been loaded as we expect by plotting the patient's treatment and imaging timeline. Here you should verify that the imaging dates, treatment timelines, and treatment dosages are correct.</p>"},{"location":"tutorials/HGG_Demo/#estimate-cellularity-from-adc","title":"Estimate cellularity from ADC\u00b6","text":"<p>The tumor cellularity, $N(\\mathbf{x},t_i)$ can be estimated from the ADC map according to the equation: $$ N(\\mathbf{x},t_i) = \\frac{ADC_\\text{w}-ADC(\\mathbf{x},t_i)}{ADC(\\mathbf{x},t_i)-ADC_\\text{min}}, $$ This is implemented in the <code>ADC_to_cellularity</code>. Let's go ahead and convert the ADC maps for all visits into cellularity maps.</p>"},{"location":"tutorials/HGG_Demo/#step-2-create-tumor-growth-model","title":"Step 2: Create Tumor Growth Model\u00b6","text":""},{"location":"tutorials/HGG_Demo/#preparing-a-reaction-diffusion-model","title":"Preparing a Reaction-Diffusion model\u00b6","text":"<p>$$     \\frac{\\partial N(\\textbf{x},t)}{\\partial t} = \\underbrace{\\nabla \\cdot \\left( D \\nabla N(\\textbf{x},t) \\right)}_{\\text{invasion}} + \\underbrace{k(\\textbf{x})N(\\textbf{x},t) \\left(1 - \\frac{N(\\textbf{x},t)}{\\theta} \\right)}_{\\text{logistic growth}}     \\quad \\underbrace{- \\sum_{i=1}^{n_{\\text{CT}}} \\sum_{j=1}^{T_i}\\alpha_i C_i e^{-\\beta_i\\left( t-\\tau_{i,j}\\right)} N(\\textbf{x},t)}_{\\text{chemotherapy}} $$ $$     N(\\textbf{x},t)_{\\text{after}} = \\underbrace{N(\\textbf{x},t)_{\\text{before}}e^{-a_{RT}d_{RT}(t)-\\beta_{RT}d_{RT}(t)^2}}_{\\text{radiotherapy}}    $$</p> <p>Model Parameters:</p> <ul> <li>$k$ : Proliferation Rate</li> <li>$d$ : Diffusivity</li> <li>$\\theta$ : Carrying capacity</li> <li>$N(\\textbf{x},0)$ : Initial condition for the tumor cellularity - we use the cellularity map derived from the first visit MRI data</li> </ul>"},{"location":"tutorials/HGG_Demo/#step-3-create-a-solver-object","title":"Step 3: Create a Solver object\u00b6","text":"<p>Under the hood, our <code>ReactionDiffusion3D</code> model is actually a spatially discretized version of the reaction-diffusion PDE. Solving this semi-discrete model requires solving a large system of ordinary differential equations (ODEs). We do this via the <code>torchdiffeq</code> library, using the <code>TorchDiffEqSolver</code> object.</p> <p>The <code>TorchDiffEqSolverOptions</code> object contains standard solver options such as the method to use (e.g. fourth-order Runge-Kutta or \"rk4\"), the timestep to use for solving, and whether to use the adjoint method for gradient computations (<code>False</code> would resort to automatic differentiation).</p>"},{"location":"tutorials/HGG_Demo/#step-4-make-a-prediction","title":"Step 4: Make a prediction\u00b6","text":"<p>We are now ready to leverage our model and solver to make a prediction of tumor growth and response to treatment.</p> <p>We will use the measured cellularity map from the first patient visit (<code>measured_cellularity_maps[0]</code>) as an initial condition for the model, and make a prediction from the first visit date until the final visit date: a total of <code>225 days</code>. We will output the solution every <code>0.5 days</code>.</p>"},{"location":"tutorials/HGG_Demo/#visualize-the-predicted-tumor-growth","title":"Visualize the predicted tumor growth\u00b6","text":"<p>Let's plot our solution. We will use the Total Tumor Cell Count (TCC) as a simple measure of the tumor size: $$ \\text{TTC}(t) = \\sum_\\mathbf{i} \\mathbf{N}_i(t)\\theta_{\\text{voxel}} $$ Here $\\theta_{\\text{voxel}}$ is the number of cells that fit into an image voxel.</p>"},{"location":"tutorials/HGG_Demo/#step-5-optional-compute-final-cell-count-and-its-gradient","title":"Step 5 (Optional): Compute final cell count and its gradient\u00b6","text":"<p>Let's compute $\\text{TCC}_{final}$ explicitly, and then also compute it's gradient with respect to some of the model parameters, $\\frac{\\partial \\text{TCC}_{final}}{\\partial k},  \\frac{\\partial \\text{TCC}_{final}}{\\partial d}$</p>"},{"location":"tutorials/HGG_Demo/#step-6-compare-the-model-prediction-to-patient-data","title":"Step 6: Compare the model prediction to patient data\u00b6","text":"<p>Let's compare how our model prediction based on only the first MRI visit compares with the data we have from subsequent visits:</p>"},{"location":"tutorials/HGG_Demo/#step-7-calibrate-the-model-to-patient-data-via-numerical-optimization","title":"Step 7: Calibrate the model to patient data via numerical optimization\u00b6","text":"<p>Rather than a trial-and-error approach, we can instead leverage numerical optimization to calibrate our model parameters to better match the observed data.</p> <p>We will use the Levenberg-Marquardt (LM) algorithm (Wikipedia Link). This algorithm will seek to minimize the sum-of-squares difference between our predicted cellularity fields and the measured cellularity fields., i.e.,</p> <p>$$ \\sum_{v=0}^{\\texttt{N\\_visits}} \\sum_{j=0}^{\\texttt{N\\_voxels}} (N_j(t_v) - \\hat{N}_j(t_v))^2 $$ where $t_v$ is the time step corresponding to visit $v$, $N_j$ and $\\hat{N}_j$ are the discretized predicted and measured (respectively) cellularity values at voxel $j$.</p> <p>First we choose how many imaging visits to calibrate to by setting <code>n_calibration_targets</code>, and picking out the corresponding solutions and timepoints:</p>"},{"location":"tutorials/HGG_Demo/#create-an-optimizer-object","title":"Create an Optimizer object\u00b6","text":"<p>Finally, we set up a Levenberg-Marquardt (LM) optimizer object. We can set various algorithm hyperparameters via the <code>LMOptions()</code> object, or stick with the defaults. We also set an initial guess for the model parameters, as well as upper and lower bounds on their values. Finally, we pass the target solution values, and our <code>update_model_and_predict</code> function for the optimizer to use.</p>"},{"location":"tutorials/HGG_Demo/#run-the-optimization","title":"Run the optimization\u00b6","text":"<p>We are now ready to run the LM algorithm for a chosen number of steps.</p> <p>Consider running somewhere between <code>5</code> and <code>30</code> iterations, with more iterations providing a better quality final solution (at the cost of longer runtime).</p>"},{"location":"tutorials/HGG_Demo/#visualize-the-optimization-iterations","title":"Visualize the optimization iterations\u00b6","text":"<p>Let's visualize the progress of the optimizer by visualizing solutions at every <code>n_opt_viz</code> optimization steps.</p>"},{"location":"tutorials/HGG_Demo/#step-8-predict-patient-response-under-alternative-treatment-plan","title":"Step 8: Predict patient response under alternative treatment plan\u00b6","text":"<p>Now that we have a calibrated digital twin model, we can use it to predict how this particular patient might respond to different treatment plans.</p> <p>Recall that we calibrated the digital twin model to imaging visits acquired prior to adjuvant chemotherapy. A remaining treatment decision might be the adjuvant chemotherapy dosages and schedule. We would expect that increasing the dosage will lead to greater tumor control, but note that higher dosages are also likely to lead to greater toxicity. Let's explore the tradeoff using our calibrated digital twin model!</p> <p>First, we'll define a function that updates the remaining chemotherapy doses based on a given total chemotherapy dosage.</p>"},{"location":"tutorials/HGG_Demo/#conclusion","title":"Conclusion\u00b6","text":"<p>Here we have demonstrated the core workflows of <code>TumorTwin</code>. We have shown how to load in a patient dataset, create a tumor growth model, create a solver for the model, make predictions with the model under various parameters and treatments, and calibrate the model to patient data.</p>"},{"location":"tutorials/HGG_Demo/#discussion-questions","title":"Discussion Questions\u00b6","text":"<p>Modeling</p> <ul> <li>What effects could we add to the reaction-diffusion model?</li> </ul> <p>Calibration</p> <ul> <li>How much data is needed for calibration?</li> <li>How does the timing of the imaging visits influence the calibration performance?</li> <li>Under what conditions might the calibration be unable to uniquely identify all the parameters?</li> </ul>"},{"location":"tutorials/HGG_Gradients/","title":"HGG Gradients","text":"In\u00a0[2]: Copied! <pre>import os\nimport time\nfrom datetime import timedelta\nfrom enum import Enum\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nfrom dotenv import load_dotenv\nfrom pydantic import FilePath\n\nfrom tumortwin.models import ReactionDiffusion3D\nfrom tumortwin.postprocessing import compute_total_cell_count\nfrom tumortwin.preprocessing import ADC_to_cellularity, compute_carrying_capacity\nfrom tumortwin.solvers import TorchDiffEqSolver, TorchDiffEqSolverOptions\nfrom tumortwin.types import (\n    ChemotherapySpecification,\n    CropSettings,\n    CropTarget,\n    HGGPatientData,\n    RadiotherapySpecification,\n)\nfrom tumortwin.utils import daterange\n</pre> import os import time from datetime import timedelta from enum import Enum from pathlib import Path  import matplotlib.pyplot as plt import numpy as np import torch from dotenv import load_dotenv from pydantic import FilePath  from tumortwin.models import ReactionDiffusion3D from tumortwin.postprocessing import compute_total_cell_count from tumortwin.preprocessing import ADC_to_cellularity, compute_carrying_capacity from tumortwin.solvers import TorchDiffEqSolver, TorchDiffEqSolverOptions from tumortwin.types import (     ChemotherapySpecification,     CropSettings,     CropTarget,     HGGPatientData,     RadiotherapySpecification, ) from tumortwin.utils import daterange In\u00a0[3]: Copied! <pre>try:\n    patient_dir = os.environ.get(\"patient_dir\")\n    image_dir = os.environ.get(\"image_dir\")\n    assert patient_dir is not None\n    assert image_dir is not None\n    PATIENT_INFO_PATH = FilePath(patient_dir)\n    IMAGE_PATH = Path(image_dir)\nexcept:\n    raise ValueError(\"Missing environment variables! Check .env file\")\n\ncrop_settings = CropSettings(crop_to = CropTarget.ROI_ENHANCE, padding = 10, visit_index=-1)\npatient_data = HGGPatientData.from_file(\n    PATIENT_INFO_PATH, image_dir=IMAGE_PATH, crop_settings=crop_settings\n)\n</pre> try:     patient_dir = os.environ.get(\"patient_dir\")     image_dir = os.environ.get(\"image_dir\")     assert patient_dir is not None     assert image_dir is not None     PATIENT_INFO_PATH = FilePath(patient_dir)     IMAGE_PATH = Path(image_dir) except:     raise ValueError(\"Missing environment variables! Check .env file\")  crop_settings = CropSettings(crop_to = CropTarget.ROI_ENHANCE, padding = 10, visit_index=-1) patient_data = HGGPatientData.from_file(     PATIENT_INFO_PATH, image_dir=IMAGE_PATH, crop_settings=crop_settings ) In\u00a0[4]: Copied! <pre>measured_cellularity_maps = []\nfor visit in patient_data.visits:\n    cellularity = ADC_to_cellularity(\n        visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image\n    )\n    measured_cellularity_maps.append(cellularity)\n\nrt = RadiotherapySpecification(\n    alpha=0.05,\n    alpha_beta_ratio=10,\n    times=[r.time for r in patient_data.radiotherapy],\n    doses=[r.dose for r in patient_data.radiotherapy],\n)\nct_doses = [c.dose for c in patient_data.chemotherapy]\nct = ChemotherapySpecification(\n    sensitivity=0.2,\n    decay_rate=9.2420,\n    times=[c.time for c in patient_data.chemotherapy],\n    doses=[c.dose for c in patient_data.chemotherapy],\n)\n\nk = 0.05\nd = 0.1\n</pre> measured_cellularity_maps = [] for visit in patient_data.visits:     cellularity = ADC_to_cellularity(         visit.adc_image, visit.roi_enhance_image, visit.roi_nonenhance_image     )     measured_cellularity_maps.append(cellularity)  rt = RadiotherapySpecification(     alpha=0.05,     alpha_beta_ratio=10,     times=[r.time for r in patient_data.radiotherapy],     doses=[r.dose for r in patient_data.radiotherapy], ) ct_doses = [c.dose for c in patient_data.chemotherapy] ct = ChemotherapySpecification(     sensitivity=0.2,     decay_rate=9.2420,     times=[c.time for c in patient_data.chemotherapy],     doses=[c.dose for c in patient_data.chemotherapy], )  k = 0.05 d = 0.1 In\u00a0[5]: Copied! <pre>class GradientMethod(Enum):\n    FINITE_DIFFERENCE = 1\n    BACK_PROP = 2\n    ADJOINT = 3\n\n\ndef evaluate_quantity_of_interest(k: float, d: float, method: GradientMethod):\n    carrying_capacity = compute_carrying_capacity(patient_data.brainmask_image)\n    u0 = torch.from_numpy(measured_cellularity_maps[0].array)\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    def eval_qoi(k, d) -&gt; torch.Tensor:\n        k = torch.tensor(\n            k,\n            requires_grad=not (method == GradientMethod.FINITE_DIFFERENCE),\n            device=device,\n        )\n        d = torch.tensor(\n            d,\n            requires_grad=not (method == GradientMethod.FINITE_DIFFERENCE),\n            device=device,\n        )\n        theta = torch.tensor(1.0, requires_grad=False, device=device)\n\n        model = ReactionDiffusion3D(\n            k=k,\n            d=d,\n            theta=theta,\n            patient_data=patient_data,\n            initial_time=patient_data.visits[0].time,\n            chemotherapy_specifications=[ct],\n            radiotherapy_specification=rt,\n        )\n\n        solver_options = TorchDiffEqSolverOptions(\n            step_size=timedelta(days=0.5),\n            use_adjoint=(method == GradientMethod.ADJOINT),\n            device=device,\n            method=\"rk4\",\n        )\n\n        solver = TorchDiffEqSolver(model, solver_options)\n        t_initial = patient_data.visits[0].time + timedelta(days=20.0)\n        t_final = patient_data.visits[0].time + timedelta(days=32.0)\n        dt = 0.5\n        timepoints = daterange(t_initial, t_final, timedelta(days=dt))\n\n        _, predicted_cellularity_maps = solver.solve(\n            timepoints=timepoints, u_initial=u0\n        )\n\n        predicted_cell_counts = [\n            compute_total_cell_count(N, carrying_capacity)\n            for N in predicted_cellularity_maps\n        ]\n        return predicted_cell_counts[-1], model\n\n    qoi, model = eval_qoi(k, d)\n\n    if method == GradientMethod.FINITE_DIFFERENCE:\n        delta = 1e-6\n        qoi_delta_k, _ = eval_qoi(k + delta, d + delta)\n        dq_dk = (qoi_delta_k - qoi) / delta\n        del qoi_delta_k\n\n        qoi_delta_d, _ = eval_qoi(k, d + delta)\n        dq_dd = (qoi_delta_d - qoi) / delta\n        del qoi_delta_d\n    else:\n        qoi.backward()\n        dq_dk = model.k.grad\n        dq_dd = model.d.grad\n\n    return qoi, dq_dk, dq_dd\n</pre> class GradientMethod(Enum):     FINITE_DIFFERENCE = 1     BACK_PROP = 2     ADJOINT = 3   def evaluate_quantity_of_interest(k: float, d: float, method: GradientMethod):     carrying_capacity = compute_carrying_capacity(patient_data.brainmask_image)     u0 = torch.from_numpy(measured_cellularity_maps[0].array)     device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")      def eval_qoi(k, d) -&gt; torch.Tensor:         k = torch.tensor(             k,             requires_grad=not (method == GradientMethod.FINITE_DIFFERENCE),             device=device,         )         d = torch.tensor(             d,             requires_grad=not (method == GradientMethod.FINITE_DIFFERENCE),             device=device,         )         theta = torch.tensor(1.0, requires_grad=False, device=device)          model = ReactionDiffusion3D(             k=k,             d=d,             theta=theta,             patient_data=patient_data,             initial_time=patient_data.visits[0].time,             chemotherapy_specifications=[ct],             radiotherapy_specification=rt,         )          solver_options = TorchDiffEqSolverOptions(             step_size=timedelta(days=0.5),             use_adjoint=(method == GradientMethod.ADJOINT),             device=device,             method=\"rk4\",         )          solver = TorchDiffEqSolver(model, solver_options)         t_initial = patient_data.visits[0].time + timedelta(days=20.0)         t_final = patient_data.visits[0].time + timedelta(days=32.0)         dt = 0.5         timepoints = daterange(t_initial, t_final, timedelta(days=dt))          _, predicted_cellularity_maps = solver.solve(             timepoints=timepoints, u_initial=u0         )          predicted_cell_counts = [             compute_total_cell_count(N, carrying_capacity)             for N in predicted_cellularity_maps         ]         return predicted_cell_counts[-1], model      qoi, model = eval_qoi(k, d)      if method == GradientMethod.FINITE_DIFFERENCE:         delta = 1e-6         qoi_delta_k, _ = eval_qoi(k + delta, d + delta)         dq_dk = (qoi_delta_k - qoi) / delta         del qoi_delta_k          qoi_delta_d, _ = eval_qoi(k, d + delta)         dq_dd = (qoi_delta_d - qoi) / delta         del qoi_delta_d     else:         qoi.backward()         dq_dk = model.k.grad         dq_dd = model.d.grad      return qoi, dq_dk, dq_dd In\u00a0[6]: Copied! <pre>start = time.time()\nqoi_fd, dq_dk_fd, dq_dd_fd = evaluate_quantity_of_interest(\n    k, d, GradientMethod.FINITE_DIFFERENCE\n)\nend = time.time()\nelapsed_fd = end - start\n</pre> start = time.time() qoi_fd, dq_dk_fd, dq_dd_fd = evaluate_quantity_of_interest(     k, d, GradientMethod.FINITE_DIFFERENCE ) end = time.time() elapsed_fd = end - start <pre>Warning: Units of input image are UNKNOWN. Defaulting to mm.\n</pre> <pre>Forward Simulation: [1996-12-05 00:00:00 to 1996-12-17 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-12-05 00:00:00 to 1996-12-17 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [1996-12-05 00:00:00 to 1996-12-17 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> In\u00a0[7]: Copied! <pre>start = time.time()\nqoi_ad, dq_dk_ad, dq_dd_ad = evaluate_quantity_of_interest(\n    k, d, GradientMethod.BACK_PROP\n)\nend = time.time()\nelapsed_ad = end - start\n</pre> start = time.time() qoi_ad, dq_dk_ad, dq_dd_ad = evaluate_quantity_of_interest(     k, d, GradientMethod.BACK_PROP ) end = time.time() elapsed_ad = end - start <pre>Warning: Units of input image are UNKNOWN. Defaulting to mm.\n</pre> <pre>Forward Simulation: [1996-12-05 00:00:00 to 1996-12-17 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> In\u00a0[8]: Copied! <pre>start = time.time()\nqoi_adj, dq_dk_adj, dq_dd_adj = evaluate_quantity_of_interest(\n    k, d, GradientMethod.ADJOINT\n)\nend = time.time()\nelapsed_adj = end - start\n</pre> start = time.time() qoi_adj, dq_dk_adj, dq_dd_adj = evaluate_quantity_of_interest(     k, d, GradientMethod.ADJOINT ) end = time.time() elapsed_adj = end - start <pre>Warning: Units of input image are UNKNOWN. Defaulting to mm.\n</pre> <pre>Forward Simulation: [1996-12-05 00:00:00 to 1996-12-17 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> In\u00a0[9]: Copied! <pre>methods = [\"Finite Difference\", \"Backprop\", \"Adjoint Method\"]\nvariables = [\"QoI Value\", \"Gradient wrt k\", \"Gradient wrt d\", \"Elapsed Time\"]\n\n# Raw data for each method and variable (rows: methods, columns: variables)\ndata = np.array(\n    [\n        [\n            qoi_fd.detach(),\n            dq_dk_fd.detach(),\n            dq_dd_fd.detach(),\n            elapsed_fd,\n        ],  # Finite Difference (used as baseline for normalization)\n        [qoi_ad.detach(), dq_dk_ad.detach(), dq_dd_ad.detach(), elapsed_ad],  # Backprop\n        [\n            qoi_adj.detach(),\n            dq_dk_adj.detach(),\n            dq_dd_adj.detach(),\n            elapsed_adj,\n        ],  # Adjoint Method\n    ]\n)\n\n# Normalize data with respect to Finite Difference (row 0)\nnorm_data = data / data[0, :]\n\n# Plotting\nx = np.arange(len(variables))  # x positions for each variable\nbar_width = 0.25  # Width of each bar\n\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Create bars for each method\nfor i, method in enumerate(methods):\n    ax.bar(x + i * bar_width, norm_data[i], width=bar_width, label=method)\n\n# Add labels, title, and legend\nax.set_xticks(x + bar_width)\nax.set_xticklabels(variables, rotation=45, ha=\"right\")\nax.set_ylabel(\"Normalized Value\")\nax.set_title(\"Comparison of Methods Across Variables (Normalized)\")\nax.legend()\n\n# Show grid for better readability\nax.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)\n\n# Show the plot\nplt.tight_layout()\nplt.show()\n</pre> methods = [\"Finite Difference\", \"Backprop\", \"Adjoint Method\"] variables = [\"QoI Value\", \"Gradient wrt k\", \"Gradient wrt d\", \"Elapsed Time\"]  # Raw data for each method and variable (rows: methods, columns: variables) data = np.array(     [         [             qoi_fd.detach(),             dq_dk_fd.detach(),             dq_dd_fd.detach(),             elapsed_fd,         ],  # Finite Difference (used as baseline for normalization)         [qoi_ad.detach(), dq_dk_ad.detach(), dq_dd_ad.detach(), elapsed_ad],  # Backprop         [             qoi_adj.detach(),             dq_dk_adj.detach(),             dq_dd_adj.detach(),             elapsed_adj,         ],  # Adjoint Method     ] )  # Normalize data with respect to Finite Difference (row 0) norm_data = data / data[0, :]  # Plotting x = np.arange(len(variables))  # x positions for each variable bar_width = 0.25  # Width of each bar  fig, ax = plt.subplots(figsize=(10, 6))  # Create bars for each method for i, method in enumerate(methods):     ax.bar(x + i * bar_width, norm_data[i], width=bar_width, label=method)  # Add labels, title, and legend ax.set_xticks(x + bar_width) ax.set_xticklabels(variables, rotation=45, ha=\"right\") ax.set_ylabel(\"Normalized Value\") ax.set_title(\"Comparison of Methods Across Variables (Normalized)\") ax.legend()  # Show grid for better readability ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.7)  # Show the plot plt.tight_layout() plt.show()"},{"location":"tutorials/HGG_Gradients/#hgg-gradients","title":"HGG Gradients\u00b6","text":"<p>This notebook demonstrates how to compute gradients/sensitivities with different methods, and provides a brief performance comparison of each method.</p>"},{"location":"tutorials/HGG_Gradients/#load-in-hgg-patient-data","title":"Load in HGG Patient data\u00b6","text":""},{"location":"tutorials/HGG_Gradients/#create-a-wrapper-function-that-will-evaluate-some-quantity-of-interest-in-this-case-the-total-tumor-cell-count-at-the-terminal-simulation-time-as-well-as-sensitivities-with-respect-to-the-proliferation-rate-k-and-diffusion-coefficient-d-using-the-requested-gradientmethod","title":"Create a wrapper function that will evaluate some quantity of interest (in this case the total tumor cell count at the terminal simulation time), as well as sensitivities with respect to the proliferation rate, k,  and diffusion coefficient, d, using the requested GradientMethod\u00b6","text":""},{"location":"tutorials/HGG_Gradients/#profiling","title":"Profiling\u00b6","text":""},{"location":"tutorials/HGG_Gradients/#plot-results","title":"Plot results\u00b6","text":""},{"location":"tutorials/TNBC_Demo/","title":"Triple negative breast cancer (TNBC) Demo","text":"In\u00a0[28]: Copied! <pre># Set up google colab environment (if running in colab)\nimport sys\nimport importlib.util\nimport os\nfrom pathlib import Path\n\nif 'google.colab' in sys.modules:\n    !pip uninstall -y torchvision torchaudio thinc fastai\n\n    # Helper function to check if a package is installed\n    def is_package_installed(package_name):\n        return importlib.util.find_spec(package_name) is not None\n\n    # Only install TumorTwin if it's not already installed\n    if not is_package_installed(\"tumortwin\"):\n        !pip install git+https://github.com/OncologyModelingGroup/TumorTwin\n\n    # Only download and extract data if it doesn't already exist\n    data_path = Path(\"../input_files/TNBC_demo_001\")\n    if not data_path.exists():\n        !wget https://github.com/OncologyModelingGroup/TumorTwin/raw/refs/heads/main/input_files/TNBC_demo_001.tar.gz\n        !tar -xzvf TNBC_demo_001.tar.gz\n        !mkdir -p ../input_files\n        !mv TNBC_demo_001 ../input_files/TNBC_demo_001\n</pre> # Set up google colab environment (if running in colab) import sys import importlib.util import os from pathlib import Path  if 'google.colab' in sys.modules:     !pip uninstall -y torchvision torchaudio thinc fastai      # Helper function to check if a package is installed     def is_package_installed(package_name):         return importlib.util.find_spec(package_name) is not None      # Only install TumorTwin if it's not already installed     if not is_package_installed(\"tumortwin\"):         !pip install git+https://github.com/OncologyModelingGroup/TumorTwin      # Only download and extract data if it doesn't already exist     data_path = Path(\"../input_files/TNBC_demo_001\")     if not data_path.exists():         !wget https://github.com/OncologyModelingGroup/TumorTwin/raw/refs/heads/main/input_files/TNBC_demo_001.tar.gz         !tar -xzvf TNBC_demo_001.tar.gz         !mkdir -p ../input_files         !mv TNBC_demo_001 ../input_files/TNBC_demo_001 In\u00a0[2]: Copied! <pre>## Imports...\nimport os\nfrom datetime import timedelta\nfrom pathlib import Path\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport torch\nimport torch.optim as optim\nfrom dotenv import load_dotenv\nfrom pydantic import FilePath\nfrom rich import print\n\nfrom tumortwin.models import ReactionDiffusion3D\nfrom tumortwin.optimizers import LMoptimizer, LMoptions\nfrom tumortwin.postprocessing import (\n    compute_total_cell_count,\n    plot_calibration,\n    plot_calibration_iter,\n    plot_cellularity_map,\n    plot_imaging_summary,\n    plot_loss,\n    plot_maps_final,\n    plot_measured_TCC,\n    plot_patient_timeline,\n    plot_predicted_TCC,\n)\nfrom tumortwin.preprocessing import ADC_to_cellularity, compute_carrying_capacity\nfrom tumortwin.solvers import TorchDiffEqSolver, TorchDiffEqSolverOptions\nfrom tumortwin.types import (\n    ChemotherapySpecification,\n    CropSettings,\n    CropTarget,\n    TNBCPatientData,\n)\nfrom tumortwin.utils import daterange, days_since_first\n\ndevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n%matplotlib inline\nfont = {\n    \"weight\": \"normal\",\n    \"size\": 10,\n}\nmatplotlib.rc(\"font\", **font)\nmatplotlib.rc(\"figure\", dpi=300)\nmatplotlib.rc(\"savefig\", dpi=300)\n</pre> ## Imports... import os from datetime import timedelta from pathlib import Path  import matplotlib import matplotlib.pyplot as plt import numpy as np import torch import torch.optim as optim from dotenv import load_dotenv from pydantic import FilePath from rich import print  from tumortwin.models import ReactionDiffusion3D from tumortwin.optimizers import LMoptimizer, LMoptions from tumortwin.postprocessing import (     compute_total_cell_count,     plot_calibration,     plot_calibration_iter,     plot_cellularity_map,     plot_imaging_summary,     plot_loss,     plot_maps_final,     plot_measured_TCC,     plot_patient_timeline,     plot_predicted_TCC, ) from tumortwin.preprocessing import ADC_to_cellularity, compute_carrying_capacity from tumortwin.solvers import TorchDiffEqSolver, TorchDiffEqSolverOptions from tumortwin.types import (     ChemotherapySpecification,     CropSettings,     CropTarget,     TNBCPatientData, ) from tumortwin.utils import daterange, days_since_first  device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")  %matplotlib inline font = {     \"weight\": \"normal\",     \"size\": 10, } matplotlib.rc(\"font\", **font) matplotlib.rc(\"figure\", dpi=300) matplotlib.rc(\"savefig\", dpi=300) <p>Here we load in the input dataset. You will need to ensure that you have a <code>.env</code> file with the relevant paths set:</p> <pre><code>image_dir = path_to_image_folder\npatient_dir = path_to_patient_json\n</code></pre> In\u00a0[3]: Copied! <pre>PATIENT_INFO_PATH = FilePath(\"../input_files/TNBC_demo_001/TNBC_demo_001.json\")\nIMAGE_PATH = FilePath(\"../input_files/TNBC_demo_001\")\ncrop_settings = CropSettings(crop_to=CropTarget.ROI_ENHANCE, padding=10, visit_index=-1)\npatient_data = TNBCPatientData.from_file(\n    PATIENT_INFO_PATH, image_dir=IMAGE_PATH, crop_settings=crop_settings\n)\n</pre> PATIENT_INFO_PATH = FilePath(\"../input_files/TNBC_demo_001/TNBC_demo_001.json\") IMAGE_PATH = FilePath(\"../input_files/TNBC_demo_001\") crop_settings = CropSettings(crop_to=CropTarget.ROI_ENHANCE, padding=10, visit_index=-1) patient_data = TNBCPatientData.from_file(     PATIENT_INFO_PATH, image_dir=IMAGE_PATH, crop_settings=crop_settings ) In\u00a0[4]: Copied! <pre>plot_patient_timeline(patient_data)\n</pre> plot_patient_timeline(patient_data) <p>We can also plot a summary of the imaging data. Here you should verify that the images are aligned/registered, cropped appropriately, and that the anatomic (T1), apparent diffusion coefficient (ADC), and region-of-interest (ROI) images are as expected.</p> In\u00a0[5]: Copied! <pre>plot_imaging_summary(patient_data)\n</pre> plot_imaging_summary(patient_data) In\u00a0[6]: Copied! <pre>measured_cellularity_maps = [\n    ADC_to_cellularity(\n        visit.adc_image, visit.roi_enhance_image\n    )\n    for visit in patient_data.visits\n]\n</pre> measured_cellularity_maps = [     ADC_to_cellularity(         visit.adc_image, visit.roi_enhance_image     )     for visit in patient_data.visits ] In\u00a0[7]: Copied! <pre>k = torch.tensor(0.025, requires_grad=True, device=device)\nd = torch.tensor(0.05, requires_grad=True, device=device)\ntheta = torch.tensor(1.0, requires_grad=False, device=device)\n</pre> k = torch.tensor(0.025, requires_grad=True, device=device) d = torch.tensor(0.05, requires_grad=True, device=device) theta = torch.tensor(1.0, requires_grad=False, device=device) <p>Chemotherapy parameters:</p> <p>Note: Here we are working with only one chemotherapy drug, so $n_{\\text{CT}}=1$</p> <ul> <li>$\\alpha_{1}$ : Chemotherapy sensitivity parameter, see <code>ChemotherapySpecification.sensitivty</code></li> <li>$\\beta_{1}$: : Chemotherapy decay rate, see <code>ChemotherapySpecification.decay_rate</code></li> <li>$C_{1}(d_{CT},t)$ : Chemotherapy drug concentration, which depends on the dosage given, and time since dosage was given.</li> </ul> <p>We can set up a <code>ChemotherapySpecification</code> using the treatment plan (times and dosages) that we loaded from the patient json file, which are now stored within the <code>TNBCPatientData</code> object:</p> In\u00a0[8]: Copied! <pre>ct = ChemotherapySpecification(\n    sensitivity=0.2,\n    decay_rate=0.7,\n    times=[c.time for c in patient_data.chemotherapy],\n    doses=[c.dose for c in patient_data.chemotherapy],\n)\n# print(ct)\n</pre> ct = ChemotherapySpecification(     sensitivity=0.2,     decay_rate=0.7,     times=[c.time for c in patient_data.chemotherapy],     doses=[c.dose for c in patient_data.chemotherapy], ) # print(ct) <p>Finally, we can set up the <code>ReactionDiffusion3D</code> model object.</p> In\u00a0[9]: Copied! <pre>model = ReactionDiffusion3D(\n    k=k,\n    d=d,\n    theta=theta,\n    patient_data=patient_data,\n    initial_time=patient_data.visits[0].time,\n    chemotherapy_specifications=[ct],\n    radiotherapy_specification=None,\n)\n</pre> model = ReactionDiffusion3D(     k=k,     d=d,     theta=theta,     patient_data=patient_data,     initial_time=patient_data.visits[0].time,     chemotherapy_specifications=[ct],     radiotherapy_specification=None, ) In\u00a0[10]: Copied! <pre>solver_options = TorchDiffEqSolverOptions(\n    step_size=timedelta(days=0.5),\n    use_adjoint=True,\n    device=device,\n    method=\"rk4\",\n)\n\nsolver = TorchDiffEqSolver(model, solver_options)\n</pre> solver_options = TorchDiffEqSolverOptions(     step_size=timedelta(days=0.5),     use_adjoint=True,     device=device,     method=\"rk4\", )  solver = TorchDiffEqSolver(model, solver_options) In\u00a0[11]: Copied! <pre>timepoints = daterange(\n    patient_data.visits[0].time, patient_data.visits[-1].time, timedelta(days=0.5)\n)\nu0 = torch.from_numpy(measured_cellularity_maps[0].array)\n\ntimes, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)\n</pre> timepoints = daterange(     patient_data.visits[0].time, patient_data.visits[-1].time, timedelta(days=0.5) ) u0 = torch.from_numpy(measured_cellularity_maps[0].array)  times, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0) <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> In\u00a0[12]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(5, 2))\nplot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax)\nplt.show()\n</pre> fig, ax = plt.subplots(1, 1, figsize=(5, 2)) plot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax) plt.show() In\u00a0[13]: Copied! <pre>fig, axes = plt.subplots(1, 5, figsize=(5, 2))\nfor i, t in enumerate([0,25, 50, 100, 119]):\n    time_days = np.array([days_since_first(t, timepoints[0]) for t in timepoints])\n    t_idx = np.where(time_days == t)[0][0]\n    plot_cellularity_map(\n        predicted_cellularity_maps[t_idx], patient_data, time=t, ax=axes[i]\n    )\n\nplt.show()\n    \n</pre> fig, axes = plt.subplots(1, 5, figsize=(5, 2)) for i, t in enumerate([0,25, 50, 100, 119]):     time_days = np.array([days_since_first(t, timepoints[0]) for t in timepoints])     t_idx = np.where(time_days == t)[0][0]     plot_cellularity_map(         predicted_cellularity_maps[t_idx], patient_data, time=t, ax=axes[i]     )  plt.show()      In\u00a0[14]: Copied! <pre>carrying_capacity = compute_carrying_capacity(patient_data.breastmask_image)\nfinal_tumor_cell_count = compute_total_cell_count(\n    predicted_cellularity_maps[-1], carrying_capacity\n)\nprint(final_tumor_cell_count)\n</pre> carrying_capacity = compute_carrying_capacity(patient_data.breastmask_image) final_tumor_cell_count = compute_total_cell_count(     predicted_cellularity_maps[-1], carrying_capacity ) print(final_tumor_cell_count) <pre>Warning: Units of input image are UNKNOWN. Defaulting to mm.\n</pre> <pre>tensor(1.5552e+09, dtype=torch.float64, grad_fn=&lt;MulBackward0&gt;)\n</pre> <p>To compute the gradients, we need to run a backwards (adjoint) solve. We can do this using the standard <code>PyTorch</code> approach of calling <code>.backward()</code> on the final tumor_cell_count to populate the gradients.</p> In\u00a0[15]: Copied! <pre>final_tumor_cell_count.backward()\n\nk_grad = model.k.grad\nprint(f\"Gradient of the final TCC w.r.t proliferation rate: {k_grad}\")\n\nd_grad = model.d.grad\nprint(f\"Gradient of the final TCC w.r.t diffusion rate: {d_grad}\")\n</pre> final_tumor_cell_count.backward()  k_grad = model.k.grad print(f\"Gradient of the final TCC w.r.t proliferation rate: {k_grad}\")  d_grad = model.d.grad print(f\"Gradient of the final TCC w.r.t diffusion rate: {d_grad}\") <pre>Gradient of the final TCC w.r.t proliferation rate: 118716014592.0\n</pre> <pre>Gradient of the final TCC w.r.t diffusion rate: 3088261888.0\n</pre> In\u00a0[19]: Copied! <pre># plot TCC vs. time for predictions and measurements\nfig, ax = plt.subplots(1, 1, figsize=(5,2))\nplot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax)\nplot_measured_TCC(\n    [m.array for m in measured_cellularity_maps],\n    [v.time for v in patient_data.visits],\n    ax=ax,\n)\nax.legend([\"predicted\", \"measured\"]);\n\n# plot cellularity maps for predictions and measurements\nfig, axs = plt.subplots(2, len(patient_data.visit_days), figsize=(5,4))\nfor i, t in enumerate(patient_data.visit_days):\n    time_days = np.array([days_since_first(t, timepoints[0]) for t in timepoints])\n    t_idx = np.where(time_days == t)[0][0]\n    plot_cellularity_map(\n        predicted_cellularity_maps[t_idx], patient_data, time=t, ax=axs[0,i]\n    )\n    plot_cellularity_map(\n        torch.tensor(measured_cellularity_maps[i].array), patient_data, time=t, ax=axs[1,i]\n    )\naxs[0,0].set_ylabel('Predicted')\naxs[1,0].set_ylabel('Measured');\nplt.show()\n</pre> # plot TCC vs. time for predictions and measurements fig, ax = plt.subplots(1, 1, figsize=(5,2)) plot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax) plot_measured_TCC(     [m.array for m in measured_cellularity_maps],     [v.time for v in patient_data.visits],     ax=ax, ) ax.legend([\"predicted\", \"measured\"]);  # plot cellularity maps for predictions and measurements fig, axs = plt.subplots(2, len(patient_data.visit_days), figsize=(5,4)) for i, t in enumerate(patient_data.visit_days):     time_days = np.array([days_since_first(t, timepoints[0]) for t in timepoints])     t_idx = np.where(time_days == t)[0][0]     plot_cellularity_map(         predicted_cellularity_maps[t_idx], patient_data, time=t, ax=axs[0,i]     )     plot_cellularity_map(         torch.tensor(measured_cellularity_maps[i].array), patient_data, time=t, ax=axs[1,i]     ) axs[0,0].set_ylabel('Predicted') axs[1,0].set_ylabel('Measured'); plt.show() <p>Not very good! We see that our model is significantly under-predicting the size/intensity of the tumor.</p> <ul> <li>Perhaps this patient has a more aggressive tumor? We could try increasing the tumor proliferation rate, $k$, or the diffusion rate $d$?</li> <li>Perhaps they are not responding to treatment as well as we thought? We could try reducing the chemosensitivity parameters, $\\alpha$?</li> </ul> In\u00a0[20]: Copied! <pre># How many imaging dates do we want to try and match\nn_visits_calibration = 2 # *Including* the initial visit\n\ntarget_timepoints = [visit.time for visit in patient_data.visits[:n_visits_calibration]]\ntarget_solution = torch.stack(\n    tuple(\n        [\n            torch.from_numpy(m.array)\n            for m in measured_cellularity_maps[: n_visits_calibration]\n        ]\n    )\n)\n</pre> # How many imaging dates do we want to try and match n_visits_calibration = 2 # *Including* the initial visit  target_timepoints = [visit.time for visit in patient_data.visits[:n_visits_calibration]] target_solution = torch.stack(     tuple(         [             torch.from_numpy(m.array)             for m in measured_cellularity_maps[: n_visits_calibration]         ]     ) ) <p>Next we create a helper function for the optimizer. This function simply takes a set of parameter values, updates the model with these parameter values, runs a forward solve, and outputs the solution at the target timepoints.</p> In\u00a0[21]: Copied! <pre>def update_model_and_predict(model_parameters, timepoints = target_timepoints):\n    d, k, ct_sens = torch.nn.Parameter(model_parameters)\n    solver.model.d = torch.nn.Parameter(d)\n    solver.model.k = torch.nn.Parameter(k)\n    solver.model.chemotherapy_specifications[0].sensitivity = torch.nn.Parameter(ct_sens)\n\n    _, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)\n    return predicted_cellularity_maps\n</pre> def update_model_and_predict(model_parameters, timepoints = target_timepoints):     d, k, ct_sens = torch.nn.Parameter(model_parameters)     solver.model.d = torch.nn.Parameter(d)     solver.model.k = torch.nn.Parameter(k)     solver.model.chemotherapy_specifications[0].sensitivity = torch.nn.Parameter(ct_sens)      _, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)     return predicted_cellularity_maps In\u00a0[22]: Copied! <pre># initial guess for the optimizer - here we use the values currently stored in the model\n# initial_parameters = torch.tensor((solver.model.d, solver.model.k, solver.model.radiotherapy_specification.alpha, solver.model.chemotherapy_specifications[0].sensitivity))\ninitial_parameters = torch.tensor((0.025, 0.05, 0.5))\noptions = LMoptions()\noptim = LMoptimizer(\n    model=update_model_and_predict,\n    initial_guess=initial_parameters,\n    bounds=torch.tensor(((0.0, 2), (0.0, 0.5), (0.0, 1.0))),\n    y_data=target_solution,\n    options=options,\n)\n</pre> # initial guess for the optimizer - here we use the values currently stored in the model # initial_parameters = torch.tensor((solver.model.d, solver.model.k, solver.model.radiotherapy_specification.alpha, solver.model.chemotherapy_specifications[0].sensitivity)) initial_parameters = torch.tensor((0.025, 0.05, 0.5)) options = LMoptions() optim = LMoptimizer(     model=update_model_and_predict,     initial_guess=initial_parameters,     bounds=torch.tensor(((0.0, 2), (0.0, 0.5), (0.0, 1.0))),     y_data=target_solution,     options=options, ) In\u00a0[24]: Copied! <pre># Run optimization for n_iter steps\nn_iter = 15\n\nfor i in range(n_iter):\n    print(\"Optimization Step: \" + str(i+1) +\"/\"+str(n_iter))\n    optim.step()\n\nbest_parameters = optim.parameters[-1]\nprint(\"Best parameters: \", best_parameters)\n</pre> # Run optimization for n_iter steps n_iter = 15  for i in range(n_iter):     print(\"Optimization Step: \" + str(i+1) +\"/\"+str(n_iter))     optim.step()  best_parameters = optim.parameters[-1] print(\"Best parameters: \", best_parameters) <pre>Optimization Step: 1/15\n</pre> <pre>Initial step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>/Users/mkapteyn/dev/tumortwin/venv/lib/python3.12/site-packages/tumortwin/optimizers/lm_optimizer.py:285: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).\n  return torch.tensor((deltaY - self.y) / delta, dtype=torch.float64)\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>/Users/mkapteyn/dev/tumortwin/venv/lib/python3.12/site-packages/tumortwin/optimizers/lm_optimizer.py:303: UserWarning: The use of `x.T` on tensors of dimension other than 2 to reverse their shape is deprecated and it will throw an error in a future release. Consider `x.mT` to transpose batches of matrices or `x.permute(*torch.arange(x.ndim - 1, -1, -1))` to reverse the dimensions of a tensor. (Triggered internally at /Users/runner/work/pytorch/pytorch/pytorch/aten/src/ATen/native/TensorShape.cpp:3641.)\n  e = solution_deltas.T @ solution_deltas\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 2/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 3/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 4/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 5/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 6/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 7/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 8/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 9/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 10/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 11/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 12/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 13/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 14/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Optimization Step: 15/15\n</pre> <pre>Accepted step\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2001-11-10 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Best parameters:  tensor([0.0965, 0.0521, 0.2300], dtype=torch.float64, grad_fn=&lt;CopySlices&gt;)\n</pre> In\u00a0[25]: Copied! <pre>n_opt_viz = 2\nsols = []\nfor params in optim.parameters[::n_opt_viz]:\n    predicted_cellularity_maps = update_model_and_predict(params, timepoints)\n    sols.append(predicted_cellularity_maps)\n</pre> n_opt_viz = 2 sols = [] for params in optim.parameters[::n_opt_viz]:     predicted_cellularity_maps = update_model_and_predict(params, timepoints)     sols.append(predicted_cellularity_maps) <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <p>Now we plot the solutions visited by the optimizer, along with the corresponding loss (sum-of-squares error) values:</p> In\u00a0[27]: Copied! <pre>fig, ax =plt.subplots(1,1, figsize=(5,2))\nplot_calibration_iter(\n    sols, carrying_capacity, timepoints, measured_cellularity_maps, patient_data, t_calibration_end=target_timepoints[-1], ax=ax\n)\n\nfig, ax =plt.subplots(1,1, figsize=(5,2))\nplot_loss(torch.tensor(optim.error), ax=ax)\n</pre> fig, ax =plt.subplots(1,1, figsize=(5,2)) plot_calibration_iter(     sols, carrying_capacity, timepoints, measured_cellularity_maps, patient_data, t_calibration_end=target_timepoints[-1], ax=ax )  fig, ax =plt.subplots(1,1, figsize=(5,2)) plot_loss(torch.tensor(optim.error), ax=ax) <p>For this particular dataset, we know what the ground-truth parameter values are since we used them to generate the data! Of course, in a real scenario you wouldn't know what the \"true\" parameters are. In fact, the data might not exactly match the model for any value of the parameters.</p> <p>Ideally, our calibrated parameter values will be close to these, so let's compute the relative error in each parameter:</p> In\u00a0[26]: Copied! <pre>true_parameters = torch.tensor((0.1,0.05, 0.2))\nfinal_parameters = optim.parameters[-1]\n\n\ndef relative_error_2dp(estimate, truth):\n    return (100*abs(truth-estimate)/truth).round(decimals=2)\n\n\nprint(f\"Error in d: {relative_error_2dp(final_parameters[0], true_parameters[0])}%\")\nprint(f\"Error in k: {relative_error_2dp(final_parameters[1], true_parameters[1])}%\")\nprint(f\"Error in ct_sens: {relative_error_2dp(final_parameters[2], true_parameters[2])}%\")\n</pre> true_parameters = torch.tensor((0.1,0.05, 0.2)) final_parameters = optim.parameters[-1]   def relative_error_2dp(estimate, truth):     return (100*abs(truth-estimate)/truth).round(decimals=2)   print(f\"Error in d: {relative_error_2dp(final_parameters[0], true_parameters[0])}%\") print(f\"Error in k: {relative_error_2dp(final_parameters[1], true_parameters[1])}%\") print(f\"Error in ct_sens: {relative_error_2dp(final_parameters[2], true_parameters[2])}%\") <pre>Error in d: 3.53%\n</pre> <pre>Error in k: 4.29%\n</pre> <pre>Error in ct_sens: 14.99%\n</pre> In\u00a0[29]: Copied! <pre>def update_ct_total_dose(ct : ChemotherapySpecification, total_dose : float):\n    current_total_dose : float = np.sum(np.array(ct.doses))\n    additional_dose = total_dose - current_total_dose\n\n    adjuvant_total_dose = np.sum(ct.doses[4:])\n    dose_multiplier = (additional_dose+adjuvant_total_dose) / adjuvant_total_dose\n    ct.doses[4:] = [d*dose_multiplier for d in ct.doses[4:]]\n    return ct\n</pre> def update_ct_total_dose(ct : ChemotherapySpecification, total_dose : float):     current_total_dose : float = np.sum(np.array(ct.doses))     additional_dose = total_dose - current_total_dose      adjuvant_total_dose = np.sum(ct.doses[4:])     dose_multiplier = (additional_dose+adjuvant_total_dose) / adjuvant_total_dose     ct.doses[4:] = [d*dose_multiplier for d in ct.doses[4:]]     return ct <p>Now let's predict the tumor response for a range of total dosages, and plot the results:</p> In\u00a0[30]: Copied! <pre>sols = []\ncandidate_doses = [20,30, 40, 50, 60]\n\nfig, ax = plt.subplots(1, 1, figsize=(5, 2))\nfor ct_total_dose in candidate_doses:\n    update_ct_total_dose(ct, ct_total_dose)\n    solver.model.chemotherapy_specifications = [ct]\n    print(f\"Running forward solve with total dose = {ct_total_dose}\")\n    times, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)\n    plot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax, alpha= 0.25 + 0.75*(ct_total_dose-min(candidate_doses))/(max(candidate_doses)-min(candidate_doses)))\n\nax.legend([\"Total dose: \"+str(d) for d in candidate_doses]);\nplt.show()\n</pre> sols = [] candidate_doses = [20,30, 40, 50, 60]  fig, ax = plt.subplots(1, 1, figsize=(5, 2)) for ct_total_dose in candidate_doses:     update_ct_total_dose(ct, ct_total_dose)     solver.model.chemotherapy_specifications = [ct]     print(f\"Running forward solve with total dose = {ct_total_dose}\")     times, predicted_cellularity_maps = solver.solve(timepoints=timepoints, u_initial=u0)     plot_predicted_TCC(predicted_cellularity_maps, timepoints, ax=ax, alpha= 0.25 + 0.75*(ct_total_dose-min(candidate_doses))/(max(candidate_doses)-min(candidate_doses)))  ax.legend([\"Total dose: \"+str(d) for d in candidate_doses]); plt.show() <pre>Running forward solve with total dose = 20\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Running forward solve with total dose = 30\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Running forward solve with total dose = 40\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Running forward solve with total dose = 50\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre> <pre>Running forward solve with total dose = 60\n</pre> <pre>Forward Simulation: [2001-09-14 00:00:00 to 2002-01-11 00:00:00 with timestep 0.50 days]:   0%|          | 0.0\u2026</pre>"},{"location":"tutorials/TNBC_Demo/#triple-negative-breast-cancer-tnbc-demo","title":"Triple negative breast cancer (TNBC) Demo\u00b6","text":"<p>This demo showcases an end-to-end image-guided digital twin workflow with <code>TumorTwin</code>.</p>"},{"location":"tutorials/TNBC_Demo/#table-of-contents","title":"\ud83d\udcda Table of Contents\u00b6","text":"<ul> <li>Step 1: Data Loading</li> <li>Step 2: Create Tumor Growth Model</li> <li>Step 3: Create a Solver object</li> <li>Step 4: Make a prediction</li> <li>Step 5 (Optional): Compute a quantity of interest and its gradient</li> <li>Step 6: Compare the model prediction to patient data</li> <li>Step 7: Calibrate the model to patient data via numerical optimization</li> <li>Step 8: Predict patient response under alternative treatment plan</li> <li>Conclusion &amp; Discussion questions</li> </ul>"},{"location":"tutorials/TNBC_Demo/#step-1-data-loading","title":"Step 1: Data Loading\u00b6","text":""},{"location":"tutorials/TNBC_Demo/#create-patientdata-object","title":"Create PatientData object\u00b6","text":""},{"location":"tutorials/TNBC_Demo/#visualize-the-data","title":"Visualize the data\u00b6","text":"<p>We can visually verify that the dataset has been loaded as we expect by plotting the patient's treatment and imaging timeline. Here you should verify that the imaging dates, treatment timelines, and treatment dosages are correct.</p>"},{"location":"tutorials/TNBC_Demo/#estimate-cellularity-from-adc","title":"Estimate cellularity from ADC\u00b6","text":"<p>The tumor cellularity, $N(\\mathbf{x},t_i)$ can be estimated from the ADC map according to the equation: $$ N(\\mathbf{x},t_i) = \\frac{ADC_\\text{w}-ADC(\\mathbf{x},t_i)}{ADC(\\mathbf{x},t_i)-ADC_\\text{min}}, $$ This is implemented in the <code>ADC_to_cellularity</code>. Let's go ahead and convert the ADC maps for all visits into cellularity maps.</p>"},{"location":"tutorials/TNBC_Demo/#step-2-create-tumor-growth-model","title":"Step 2: Create Tumor Growth Model\u00b6","text":""},{"location":"tutorials/TNBC_Demo/#preparing-a-reaction-diffusion-model","title":"Preparing a Reaction-Diffusion model\u00b6","text":"<p>$$     \\frac{\\partial N(\\textbf{x},t)}{\\partial t} = \\underbrace{\\nabla \\cdot \\left( D \\nabla N(\\textbf{x},t) \\right)}_{\\text{invasion}} + \\underbrace{k(\\textbf{x})N(\\textbf{x},t) \\left(1 - \\frac{N(\\textbf{x},t)}{\\theta} \\right)}_{\\text{logistic growth}}     \\quad \\underbrace{- \\sum_{i=1}^{n_{\\text{CT}}} \\sum_{j=1}^{T_i}\\alpha_i C_i e^{-\\beta_i\\left( t-\\tau_{i,j}\\right)} N(\\textbf{x},t)}_{\\text{chemotherapy}} $$ $$     N(\\textbf{x},t)_{\\text{after}} = \\underbrace{N(\\textbf{x},t)_{\\text{before}}e^{-a_{RT}d_{RT}(t)-\\beta_{RT}d_{RT}(t)^2}}_{\\text{radiotherapy}}    $$</p> <p>Model Parameters:</p> <ul> <li>$k$ : Proliferation Rate</li> <li>$d$ : Diffusivity</li> <li>$\\theta$ : Carrying capacity</li> <li>$N(\\textbf{x},0)$ : Initial condition for the tumor cellularity - we use the cellularity map derived from the first visit MRI data</li> </ul>"},{"location":"tutorials/TNBC_Demo/#step-3-create-a-solver-object","title":"Step 3: Create a Solver object\u00b6","text":"<p>Under the hood, our <code>ReactionDiffusion3D</code> model is actually a spatially discretized version of the reaction-diffusion PDE. Solving this semi-discrete model requires solving a large system of ordinary differential equations (ODEs). We do this via the <code>torchdiffeq</code> library, using the <code>TorchDiffEqSolver</code> object.</p> <p>The <code>TorchDiffEqSolverOptions</code> object contains standard solver options such as the method to use (e.g. fourth-order Runge-Kutta or \"rk4\"), the timestep to use for solving, and whether to use the adjoint method for gradient computations (<code>False</code> would resort to automatic differentiation).</p>"},{"location":"tutorials/TNBC_Demo/#step-4-make-a-prediction","title":"Step 4: Make a prediction\u00b6","text":"<p>We are now ready to leverage our model and solver to make a prediction of tumor growth and response to treatment.</p> <p>We will use the measured cellularity map from the first patient visit (<code>measured_cellularity_maps[0]</code>) as an initial condition for the model, and make a prediction from the first visit date until the final visit date: a total of <code>119 days</code>. We will output the solution every <code>0.5 days</code>.</p>"},{"location":"tutorials/TNBC_Demo/#visualize-the-predicted-tumor-growth","title":"Visualize the predicted tumor growth\u00b6","text":"<p>Let's plot our solution. We will use the Total Tumor Cell Count (TCC) as a simple measure of the tumor size: $$ \\text{TTC}(t) = \\sum_\\mathbf{i} \\mathbf{N}_i(t)\\theta_{\\text{voxel}} $$ Here $\\theta_{\\text{voxel}}$ is the number of cells that fit into an image voxel.</p>"},{"location":"tutorials/TNBC_Demo/#step-5-optional-compute-final-cell-count-and-its-gradient","title":"Step 5 (Optional): Compute final cell count and its gradient\u00b6","text":"<p>Let's compute $\\text{TCC}_{final}$ explicitly, and then also compute it's gradient with respect to some of the model parameters, $\\frac{\\partial \\text{TCC}_{final}}{\\partial k},  \\frac{\\partial \\text{TCC}_{final}}{\\partial d}$</p>"},{"location":"tutorials/TNBC_Demo/#step-6-compare-the-model-prediction-to-patient-data","title":"Step 6: Compare the model prediction to patient data\u00b6","text":"<p>Let's compare how our model prediction based on only the first MRI visit compares with the data we have from subsequent visits:</p>"},{"location":"tutorials/TNBC_Demo/#step-7-calibrate-the-model-to-patient-data-via-numerical-optimization","title":"Step 7: Calibrate the model to patient data via numerical optimization\u00b6","text":"<p>Rather than a trial-and-error approach, we can instead leverage numerical optimization to calibrate our model parameters to better match the observed data.</p> <p>We will use the Levenberg-Marquardt (LM) algorithm (Wikipedia Link). This algorithm will seek to minimize the sum-of-squares difference between our predicted cellularity fields and the measured cellularity fields., i.e.,</p> <p>$$ \\sum_{v=0}^{\\texttt{N\\_visits}} \\sum_{j=0}^{\\texttt{N\\_voxels}} (N_j(t_v) - \\hat{N}_j(t_v))^2 $$ where $t_v$ is the time step corresponding to visit $v$, $N_j$ and $\\hat{N}_j$ are the discretized predicted and measured (respectively) cellularity values at voxel $j$.</p> <p>First we choose how many imaging visits to calibrate to by setting <code>n_calibration_targets</code>, and picking out the corresponding solutions and timepoints:</p>"},{"location":"tutorials/TNBC_Demo/#create-an-optimizer-object","title":"Create an Optimizer object\u00b6","text":"<p>Finally, we set up a Levenberg-Marquardt (LM) optimizer object. We can set various algorithm hyperparameters via the <code>LMOptions()</code> object, or stick with the defaults. We also set an initial guess for the model parameters, as well as upper and lower bounds on their values. Finally, we pass the target solution values, and our <code>update_model_and_predict</code> function for the optimizer to use.</p>"},{"location":"tutorials/TNBC_Demo/#run-the-optimization","title":"Run the optimization\u00b6","text":"<p>We are now ready to run the LM algorithm for a chosen number of steps.</p> <p>Consider running somewhere between <code>5</code> and <code>30</code> iterations, with more iterations providing a better quality final solution (at the cost of longer runtime).</p>"},{"location":"tutorials/TNBC_Demo/#visualize-the-optimization-iterations","title":"Visualize the optimization iterations\u00b6","text":"<p>Let's visualize the progress of the optimizer by visualizing solutions at every <code>n_opt_viz</code> optimization steps.</p>"},{"location":"tutorials/TNBC_Demo/#step-8-predict-patient-response-under-alternative-treatment-plan","title":"Step 8: Predict patient response under alternative treatment plan\u00b6","text":"<p>Now that we have a calibrated digital twin model, we can use it to predict how this particular patient might respond to different treatment plans.</p> <p>Recall that we calibrated the digital twin model to imaging visits acquired after four weeks of neoadjuvant chemotherapy. A remaining treatment decision might be the neoadjuvant chemotherapy dosages and schedule. We would expect that increasing the dosage will lead to greater tumor control, but note that higher dosages are also likely to lead to greater toxicity. Let's explore the tradeoff using our calibrated digital twin model!</p> <p>First, we'll define a function that updates the remaining chemotherapy doses based on a given total chemotherapy dosage.</p>"},{"location":"tutorials/TNBC_Demo/#conclusion","title":"Conclusion\u00b6","text":"<p>Here we have demonstrated the core workflows of <code>TumorTwin</code>. We have shown how to load in a patient dataset, create a tumor growth model, create a solver for the model, make predictions with the model under various parameters and treatments, and calibrate the model to patient data.</p>"},{"location":"tutorials/TNBC_Demo/#discussion-questions","title":"Discussion Questions\u00b6","text":"<p>Modeling</p> <ul> <li>What effects could we add to the reaction-diffusion model?</li> </ul> <p>Calibration</p> <ul> <li>How much data is needed for calibration?</li> <li>How does the timing of the imaging visits influence the calibration performance?</li> <li>Under what conditions might the calibration be unable to uniquely identify all the parameters?</li> </ul>"}]}